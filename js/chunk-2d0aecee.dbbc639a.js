(window.webpackJsonp=window.webpackJsonp||[]).push([["chunk-2d0aecee"],{"0c49":function(e,t,n){"use strict";n.d(t,"a",(function(){return i}));var i=[{key:"1",word:"什么是HTML元素",type:"HTML",details:"\n    指从开始标签到结束标签的所有代码\n    ",latestReview:"2021/1/26",nextReview:"2021/2/25",count:5},{key:"2",word:"当margin-top、padding-top的值是百分比时 分别如何计算",type:"CSS",details:"\n    margin 相对最近父级块级元素的width\n    padding 相对最近父级块级元素的width\n    ",latestReview:"2020/12/4",nextReview:"2021/1/3",count:5},{key:"3",word:"Cookie的作用",type:"HTML",details:"\n    通过在客户端 ( 浏览器 ) 记录信息确定用户身份 最大为 4 kb\n    ",latestReview:"2020/12/4",nextReview:"2021/1/3",count:10},{key:"4",word:"<svg>标签",type:"HTML",details:"\n    用来绘制矢量图\n    ",latestReview:"2020/12/2",nextReview:"2021/1/1",count:10},{key:"5",word:"CSS的作用",type:"CSS",details:"\n    用于渲染HTML元素标签的样式\n    ",latestReview:"2020/12/24",nextReview:"2021/1/23",count:5},{key:"6",word:"CSS样式由什么组成",type:"CSS",details:"\n    选择器和声明\n    ",latestReview:"2020/12/2",nextReview:"2021/1/1",count:5},{key:"7",word:"CSS声明由什么组成",type:"CSS",details:"\n    属性和值\n    ",latestReview:"",nextReview:"",count:6},{key:"8",word:"三种CSS代码插入形式",type:"CSS",details:'\n    内联式 嵌入式 外部式（外联式）\n\n    内联样式- 在HTML元素中使用"style" 属性\n    内部样式表-在HTML文档头部 <head> 区域使用<style> 元素 来包含CSS\n    外部引用 - 使用外部 CSS 文件（最好的引用方式）\n    ',latestReview:"2020/12/2",nextReview:"2021/1/1",count:5},{key:"9",word:"子选择器语法",type:"CSS",details:"\n    .类名>标签名{CSS样式代码}\n    ",latestReview:"2020/12/17",nextReview:"2021/1/16",count:10},{key:"10",word:"数组转字符",type:"javaScript",details:"\n    join()\n    ",latestReview:"",nextReview:"",count:6},{key:"11",word:"字符串转数组",type:"javaScript",details:"\n    split()\n    ",latestReview:"2020/12/18",nextReview:"2021/1/2",count:10},{key:"12",word:"浅拷贝理解",type:"javaScript",details:"\n    只针对于引用数据类型\n    浅拷贝只复制指向某个对象的指针\n    而不复制对象本身\n    新旧对象还是共享同一块内存\n    ",latestReview:"2020/12/2",nextReview:"2021/1/1",count:10},{key:"13",word:"Js 基本数据类型",type:"javaScript",details:"\n    基本数据类型：String，Boolean，Number，Undefined，Null；\n    ",latestReview:"",nextReview:"",count:6},{key:"14",word:"Js引用数据类型例",type:"javaScript",details:"\n    Object(Array，Date，RegExp，Function)；\n    在JS中除了基本数据类型以外的都是对象，数据是对象，函数是对象，正则表达式是对象\n    ",latestReview:"",nextReview:"",count:6},{key:"15",word:"基本数据类型和引用数据类型的区别",type:"javaScript",details:"\n    保存位置不同\n    基本数据类型保存在栈内存中\n    引用数据类型保存在堆内存中 然后在栈内存中保存了一个对堆内存中实际对象的引用 即数据在堆内存中的地址\n    对引用数据类型的操作都是操作对象的引用而不是实际的对象\n    ",latestReview:"2020/12/24",nextReview:"2021/1/23",count:5},{key:"16",word:"为什么基本数据类型保存在栈中 引用数据类型保存在堆中",type:"javaScript",details:"\n    1）堆比栈大，栈比堆速度快；\n    2）基本数据类型比较稳定，而且相对来说占用的内存小；\n    3）引用数据类型大小是动态的，而且是无限的；\n      引用值的大小会改变，不能把它放在栈中，否则会降低变量查找的速度，\n      因此放在变量栈空间的值是该对象存储在堆中的地址，地址的大小是固定的，所以把它存储在栈中对变量性能无任何负面影响\n    4）堆内存是无序存储，可以根据引用直接获取；\n    ",latestReview:"2021/1/21",nextReview:"2021/1/26",count:2},{key:"17",word:"访问引用类型的过程",type:"javaScript",details:"\n    js不允许直接访问保存在堆内存中的对象，所以在访问一个对象时，\n    首先得到的是这个对象在堆内存中的地址，然后再按照这个地址去获得这个对象中的值\n    ",latestReview:"",nextReview:"",count:6},{key:"18",word:"函数参数中的引用变量实际上是什么",type:"javaScript",details:"\n    是这个对象在堆内存中的内存地址\n    ECMAScript中所有函数的参数都是按值来传递的\n    对于原始值，只是把变量里的值传递给参数，之后参数和这个变量互不影响\n    因此它传递的值也就是这个内存地址\n    这也就是为什么函数内部对这个参数的修改会体现在外部的原因，因为它们都指向同一个对象\n    ",latestReview:"",nextReview:"",count:6},{key:"19",word:"基本数据类型如何判断（得到其数据类型）",type:"javaScript",details:"\n    使用typeof可以返回其基本数据类型\n    ",latestReview:"",nextReview:"",count:6},{key:"20",word:"检测null类型会返回什么 为什么",type:"javaScript",details:"\n    NULL类型会返回object\n    因为null值表示一个空对象指针\n    ",latestReview:"",nextReview:"",count:6},{key:"21",word:"检测具体对象使用什么操作符",type:"javaScript",details:"\n    instanceof\n\n    // 判断data是否为Blob文件流对象\n    例：if (data instanceof Blob) {\n      ...\n    }\n    ",latestReview:"2020/12/2",nextReview:"2021/1/1",count:5},{key:"22",word:"pop()方法",type:"javaScript",details:"\n    删除并返回数组的最后一个元素\n    ",latestReview:"2020/12/8",nextReview:"2021/1/7",count:5},{key:"23",word:"shift()方法",type:"javaScript",details:"\n    删除并返回数组的第一个元素\n    ",latestReview:"",nextReview:"",count:6},{key:"24",word:"unshift()方法",type:"javaScript",details:"\n    向数组的开头添加一个或更多元素，并返回新的长度\n\n    array.unshift(newelement1,newelement2,....,newelementX)\n    ",latestReview:"2020/12/3",nextReview:"2021/1/2",count:5},{key:"25",word:"join()方法",type:"javaScript",details:"\n    把数组的所有元素放入一个字符串。元素通过指定的分隔符进行分隔\n    ",latestReview:"2020/12/18",nextReview:"2021/1/2",count:4},{key:"26",word:"splice()方法",type:"javaScript",details:"\n    删除元素，并向数组添加新元素\n    ",latestReview:"2020/12/3",nextReview:"2021/1/2",count:5},{key:"27",word:"toString()方法",type:"javaScript",details:"\n    把数组转换为字符串，并返回结果\n    ",latestReview:"2020/12/8",nextReview:"2021/1/7",count:5},{key:"28",word:"every()方法",type:"javaScript",details:"\n    js中的迭代方法\n    用于检测数组中的元素是否满足指定条件\n\n    1、依次执行数组元素，如果一个元素不满足条件就返回false，\n      不会继续执行后面的元素判断；所有数组元素都满足条件则返回true。\n    2、不会改变原数组。\n    ",latestReview:"2020/12/3",nextReview:"2021/1/2",count:5},{key:"29",word:"some()方法",type:"javaScript",details:"\n    js中的迭代方法\n    用于检测数组中的元素是否满足指定条件\n\n    1、依次执行数组元素，如果有一个元素满足条件就返回true，\n      不会继续执行后面的元素判断；所有数组元素都不满足条件则返回false。\n    2、不会改变原数组。\n    ",latestReview:"2020/12/3",nextReview:"2021/1/2",count:5},{key:"30",word:"toString()和toLocaleString()有什么区别",type:"javaScript",details:"\n    1、当数字是四位及以上时，toLocaleString()会让数字三位一分隔\n    var a=1234\n    a.toString()  // 1234\n    a.toLocaleString()  // 1,234\n\n    2、转换时间格式上有区别\n    var sd=new Date()\n    sd.toLocaleString()  // 2017/2/15 上午11:21:31 \n    sd.toString() // Wed Feb 15 2017 11:21:31 GMT+0800 (CST)\n    ",latestReview:"2020/12/25",nextReview:"2021/1/24",count:5},{key:"31",word:"charAt()方法",type:"javaScript",details:"\n    返回在指定位置的字符\n    ",latestReview:"2020/12/3",nextReview:"2021/1/2",count:5},{key:"32",word:"深拷贝理解",type:"javaScript",details:"\n    深拷贝会另外创造一个一模一样的对象\n    新对象跟原对象不共享内存\n    修改新对象不会改到原对象\n    ",latestReview:"2020/12/3",nextReview:"2021/1/2",count:5},{key:"33",word:"什么是防抖Debounce",type:"工作经验",details:"\n    在事件被触发n秒后，再去执行回调函数。\n    如果n秒内该事件被重新触发，则重新计时。\n    结果就是将频繁触发的事件合并为一次，且在最后执行\n    ",latestReview:"",nextReview:"",count:6},{key:"34",word:"call() apply()方法是什么",type:"javaScript",details:"\n    call() 和 apply() 是预定义的函数方法\n    因为在 JavaScript 中, 函数是对象。\n    所以Js函数有它的属性和方法\n\n    可用于调用函数，两个方法的第一个参数必须是对象本身\n    ",latestReview:"",nextReview:"",count:6},{key:"35",word:"ES6 Symbol",type:"javaScript",details:"\n    表示独一无二的值\n    ",latestReview:"",nextReview:"",count:10},{key:"36",word:"原生html页面js代码在哪里写",type:"工作经验",details:"\n    body标签下创建script标签\n    ",latestReview:"2020/12/3",nextReview:"2021/1/2",count:10},{key:"37",word:"Number转布尔两种情况",type:"javaScript",details:"\n    转为true的值：任何非零数值\n    转为false的值：0和NaN\n    ",latestReview:"2020/12/3",nextReview:"2021/1/2",count:10},{key:"38",word:"其它数据类型转布尔使用什么方法",type:"javaScript",details:"\n    使用转型函数Boolean()\n    ",latestReview:"",nextReview:"",count:6},{key:"39",word:"for循环 i === 0 和 i !== 0优化写法",type:"工作经验",details:"\n    i === 0 -> !i\n    i !== 0 -> !!i\n\n    !!双重否定为肯定\n    第一个!先将number转换为boolean并取反 如果为非0数值则为false\n    第二个!再次否定变为肯定\n    ",latestReview:"",nextReview:"",count:6},{key:"40",word:"Boolean(null)",type:"javaScript",details:"\n    false\n    ",latestReview:"",nextReview:"",count:6},{key:"41",word:"Boolean(对象)",type:"javaScript",details:"\n    任意非空对象：true\n    null：false\n    ",latestReview:"2020/12/3",nextReview:"2021/1/2",count:5},{key:"42",word:"Boolean(字符串)",type:"javaScript",details:'\n    任意非空字符串：true\n    空字符串""：false\n    ',latestReview:"",nextReview:"",count:10},{key:"43",word:"Js判断无内容对象",type:"javaScript",details:"\n    if (JSON.stringify(obj) !== '{}') {\n      ...\n    }\n    ",latestReview:"2020/12/3",nextReview:"2021/1/2",count:5},{key:"44",word:'接口判断数据undfined null ""一网打尽',type:"工作经验",details:"\n    if (!!data) {\n      ...\n    }\n    ",latestReview:"2020/12/3",nextReview:"2021/1/2",count:5},{key:"45",word:"console.log(3 && 5)",type:"javaScript",details:"\n    5\n    ",latestReview:"",nextReview:"",count:6},{key:"46",word:"Promise是什么",type:"javaScript",details:"\n    是异步编程的一种解决方案 简单说就是一个容器\n    里面保存着某个未来才会结束的事件的结果\n    这个事件通常是一个异步操作\n    ",latestReview:"2020/12/8",nextReview:"2021/1/7",count:5},{key:"47",word:"overflow默认值",type:"CSS",details:"\n    visible\n    内容不会被修剪 会呈现在元素框之外 \n    ",latestReview:"",nextReview:"",count:6},{key:"48",word:"overflow auto的意思",type:"CSS",details:"\n    如果内容被修剪，则浏览器会显示滚动条以便查看其余的内容。\n    ",latestReview:"",nextReview:"",count:6},{key:"49",word:"text-overflow ellipsis意思",type:"CSS",details:"\n    显示省略符号来代表被修剪的文本\n    ",latestReview:"2020/12/8",nextReview:"2021/1/7",count:5},{key:"50",word:"created()与mounted()区别",type:"Vue",details:"\n    created()钩子函数执行的时候DOM 其实并未进行任何渲染\n    \n    mounted()钩子函数执行时所有的DOM挂载和渲染都已完成\n    此时在该钩子函数中进行任何DOM操作都不会有问题\n    ",latestReview:"",nextReview:"",count:10},{key:"51",word:"什么时候需要使用nextTick",type:"Vue",details:"\n    在数据变化后要执行的某个操作\n    而这个操作需要使用随数据改变而改变的DOM结构的时候\n    这个操作都应该放进Vue.nextTick()的回调函数中\n    ",latestReview:"",nextReview:"",count:6},{key:"52",word:"nextTick是什么意思 如何理解",type:"Vue",details:"\n    下一个事件循环\n\n    Vue 异步执行 DOM 更新\n    只要观察到数据变化，Vue 将开启一个队列\n    并缓冲在同一事件循环中发生的所有数据改变\n    如果同一个 watcher 被多次触发，只会被推入到队列中一次\n    然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际 (已去重的) 工作\n    ",latestReview:"2021/1/21",nextReview:"2021/1/28",count:10},{key:"53",word:"step > max_step && (step = min_step)等价于",type:"javaScript",details:"\n    if (step > max_step) {\n      step = min_step;\n    }\n    ",latestReview:"",nextReview:"",count:6},{key:"54",word:"Js数据类型转换有几种 分别是",type:"javaScript",details:"\n    转换为布尔值（调用Boolean()方法）\n    转换为数字（调用Number()、parseInt()和parseFloat()方法）\n    转换为字符串（调用.toString()或者String()方法）\n    ",latestReview:"",nextReview:"",count:10},{key:"55",word:'Number(null)；Number([])；Number("d")',type:"javaScript",details:'\n    Number(null) -> 0\n    Number([]) -> 0\n    Number("d") -> NaN\n    ',latestReview:"",nextReview:"",count:6},{key:"56",word:'Number([1])；Number([1, 2])；Number(["1"])',type:"javaScript",details:'\n    Number([1]) -> 1\n    Number([1, 2]) -> NaN\n    Number(["1"]) -> 1\n    ',latestReview:"2020/12/12",nextReview:"2021/1/11",count:5},{key:"57",word:"什么是Js内置对象",type:"javaScript",details:"\n    在程序执行前存在全局作用域里的由 js 定义的一些\n    「全局值、属性、函数」和用来实例化其他对象的构造函数对象\n\n    一般我们经常用到的如全局变量值 NaN、undefined\n    全局函数如 parseInt()、parseFloat()\n    用来实例化对象的构造函数如 Date、Object 等\n    还有提供数学计算的单体内置对象如 Math 对象\n    ",latestReview:"2020/12/31",nextReview:"2021/1/15",count:4},{key:"58",word:"undefined与undeclared 的区别",type:"javaScript",details:"\n    已在作用域中声明但还没有赋值的变量，是 undefined。\n    let b\n    console.log(b)  // undefined\n\n    相反，还没有在作用域中声明过的变量，是 undeclared 的。\n    对于 undeclared 变量的引用，浏览器会报引用错误，如 ReferenceError: b is not defined\n    console.log(b)  // 报错\n    ",latestReview:"2020/12/11",nextReview:"2021/1/10",count:5},{key:"59",word:"let a = [] a.toString()值是",type:"javaScript",details:'\n    ""\n    ',latestReview:"2020/12/11",nextReview:"2021/1/10",count:5},{key:"60",word:"在浏览器中this指向",type:"javaScript",details:'\n    this等价于window对象\n    用var声明一个变量和给this或者window添加属性是等价的\n\n    var name = "Jake";\n    console.log(this.name ); // "Jake"\n    console.log(window.name ); // "Jake"\n    ',latestReview:"2020/12/11",nextReview:"2021/1/10",count:5},{key:"61",word:"Js代码由谁执行",type:"javaScript",details:"\n    浏览器的Js引擎\n    ",latestReview:"2020/12/11",nextReview:"2021/1/10",count:10},{key:"62",word:"Vue组件中this指向",type:"javaScript",details:"\n    当前Vue组件\n    ",latestReview:"",nextReview:"",count:10},{key:"63",word:"如何理解构造函数",type:"javaScript",details:"\n    所谓构造函数，就是通过这个函数生成一个新对象（object）\n    ",latestReview:"2020/12/13",nextReview:"2021/1/12",count:5},{key:"64",word:"call、apply、bind被称为",type:"javaScript",details:"\n    this的强绑定\n    ",latestReview:"2020/12/20",nextReview:"2021/1/19",count:10},{key:"65",word:"call使用例子",type:"javaScript",details:"\n    var name = 'zjk';\n    function fun() {\n      console.log (this.name);\n    }\n    \n    var obj= {\n      name: 'jake'\n    };\n    fun(); // zjk\n    fun.call(obj); //Jake\n    ",latestReview:"",nextReview:"",count:6},{key:"66",word:"箭头函数中的this指向",type:"javaScript",details:"\n    es6的箭头函数中没有 this 绑定，必须通过查找作用域链来决定其值\n    如果箭头函数被非箭头函数包含，则 this 绑定的是最近一层非箭头函数的 this，否则，this 为 undefined\n    始终指向函数定义时的 this，而非执行时\n    ",latestReview:"2020/12/11",nextReview:"2021/1/10",count:5},{key:"67",word:"call、apply用途 相当于",type:"javaScript",details:"\n    在特定的作用域中调用函数\n    实际上等于设置函数体内 this 对象的值\n    ",latestReview:"",nextReview:"",count:6},{key:"68",word:"apply()方法参数",type:"javaScript",details:"\n    apply()方法接收两个参数：一个是在其中运行函数的作用域，另一个是参数数组。\n    其中，第二个参数可以是 Array 的实例，也可以是arguments 对象\n\n    function sum(num1, num2){ \n      return num1 + num2; \n    } \n    function callSum1(num1, num2){ \n      return sum.apply(this, arguments); // 传入 arguments 对象\n    } \n    function callSum2(num1, num2){ \n      return sum.apply(this, [num1, num2]); // 传入数组\n    } \n    console.log(callSum1(10,10)); //20\n    console.log(callSum2(10,10)); //20\n    ",latestReview:"2020/12/4",nextReview:"2021/1/3",count:5},{key:"69",word:"call()apply()方法区别",type:"javaScript",details:"\n    call()方法与 apply()方法的作用相同，它们的唯一区别在于接收参数的方式不同。\n    在使用call()方法时，传递给函数的参数必须逐个列举出来\n\n    function sum(num1, num2){ \n      return num1 + num2; \n    }\n    function callSum(num1, num2){ \n      return sum.call(this, num1, num2); \n    } \n    console.log(callSum(10,10)); //20\n    ",latestReview:"2020/12/11",nextReview:"2021/1/10",count:5},{key:"70",word:"call()apply()使用取决于",type:"javaScript",details:"\n    call()方法与 apply()方法返回的结果是完全相同\n    至于是使用 apply()还是 call()\n    完全取决于你采取哪种给函数传递参数的方式最方便\n\n    参数数量/顺序确定就用call，参数数量/顺序不确定的话就用apply\n    考虑可读性：参数数量不多就用call，参数数量比较多的话，把参数整合成数组，使用apply\n    ",latestReview:"2020/12/28",nextReview:"2021/1/27",count:5},{key:"71",word:"bind()方法",type:"javaScript",details:'\n    bind()方法会创建一个函数的实例，其 this 值会被绑定到传给 bind()函数的值。\n    意思就是 bind() 会返回一个新函数\n\n    window.color = "red"; \n    var o = { color: "blue" }\n    function sayColor(){ \n      alert(this.color)\n    } \n    var objectSayColor = sayColor.bind(o); \n    objectSayColor(); //blue\n    ',latestReview:"2020/12/29",nextReview:"2021/1/28",count:5},{key:"72",word:"call/apply与bind的区别",type:"javaScript",details:"\n    执行区别\n    call/apply改变了函数的this上下文后马上执行该函数\n    bind则是返回改变了上下文后的函数,不执行该函数\n\n    function add (a, b) {\n      return a + b;\n    }\n    \n    function sub (a, b) {\n        return a - b;\n    }\n    \n    add.bind(sub, 5, 3); // 这时，并不会返回 8\n    add.bind(sub, 5, 3)(); // 调用后，返回 8\n\n    返回区别\n    call/apply 返回fun的执行结果\n    bind返回fun的拷贝，并指定了fun的this指向，保存了fun的参数。\n    ",latestReview:"2020/12/29",nextReview:"2021/1/28",count:5},{key:"73",word:"call/apply/bind的核心理念",type:"javaScript",details:"\n    借\n    call/apply/bind是在向其他对象借用方法\n    ",latestReview:"2020/12/11",nextReview:"2021/1/10",count:5},{key:"74",word:"clearTimeout()",type:"javaScript",details:"\n    clearTimeout() 方法可取消由 setTimeout() 方法设置的 timeout\n\n    clearTimeout(id_of_setTimeOut)\n    id_of_setTimeOut：由 setTimeout() 返回的 ID 值。该值标识要取消的延迟执行代码块。\n\n    例：\n    let timer\n      ...\n    clearTimeout(timer)\n    timer = setTimeout(() => {\n      targetFunction.apply(ctx, args)\n    }, delay)\n    ",latestReview:"2020/12/11",nextReview:"2021/1/10",count:10},{key:"75",word:"什么是类数组",type:"javaScript",details:"\n    具备与数组特征类似的对象\n\n    类数组可以通过角标进行调用 具有length属性\n    同时也可以通过 for 循环进行遍历\n    ",latestReview:"2020/12/11",nextReview:"2021/1/10",count:5},{key:"76",word:"简易类数组",type:"javaScript",details:"\n    let arrayLike = {\n      0: 1,\n      1: 2,\n      2: 3,\n      length: 3\n    }\n    ",latestReview:"2020/12/11",nextReview:"2021/1/10",count:5},{key:"77",word:"call、apply便捷记忆法",type:"javaScript",details:"\n    猫吃鱼，狗吃肉，奥特曼打小怪兽。\n    有天狗想吃鱼了\n    猫.吃鱼.call(狗，鱼)\n    狗就吃到鱼了\n    猫成精了，想打怪兽\n    奥特曼.打小怪兽.call(猫，小怪兽)\n    猫也可以打小怪兽了\n    ",latestReview:"2020/12/11",nextReview:"2021/1/10",count:5},{key:"78",word:"Js全局对象为什么存在",type:"javaScript",details:"\n    因为代码的目的是提供动态页面\n    浏览器需要提供一个API 使Js引擎可以与代码交互改变页面内容\n    这个API通过全局对象提供\n    ",latestReview:"2020/12/26",nextReview:"2021/1/25",count:5},{key:"79",word:"window对象是什么 代表什么",type:"javaScript",details:"\n    浏览器暴露给Js引擎的主要全局对象\n    代表了包含着一个页面的窗口\n    ",latestReview:"2020/12/7",nextReview:"2021/1/6",count:5},{key:"80",word:"window对象最重要的属性是什么 代表什么",type:"javaScript",details:"\n    document\n    代表当前页面的DOM\n    ",latestReview:"2020/12/11",nextReview:"2021/1/10",count:5},{key:"81",word:"HTML节点特点",type:"HTML",details:"\n    ①所有节点都只有一个父节点（除html根节点）\n    ②一个节点可以拥有任意数量的子节点\n    ",latestReview:"2020/12/11",nextReview:"2021/1/10",count:5},{key:"82",word:"window对象的作用",type:"javaScript",details:"\n    通过window对象Js代码就能在任何程度上改变DOM\n    （修改、移除、添加新的节点）\n    ",latestReview:"2020/12/27",nextReview:"2021/1/26",count:5},{key:"83",word:"为什么script元素要放在页面底部 Js代码的局限性",type:"javaScript",details:"\n    Js不能选择和修改还未创建的节点\n    ",latestReview:"",nextReview:"",count:6},{key:"84",word:"为什么全局变量一直可以被访问到",type:"javaScript",details:"\n    因为全局window对象会存在于整个页面的生存期之间\n    它上面存储着所有的Js变量\n    ",latestReview:"2020/12/14",nextReview:"2021/1/13",count:5},{key:"85",word:"页面构建阶段的Js代码行为动作",type:"javaScript",details:"\n    ①影响全局应用状态\n    ②修改DOM\n    ③注册事件监听器（处理器）\n    ",latestReview:"2020/12/24",nextReview:"2021/1/23",count:5},{key:"86",word:"事件监听器如何触发",type:"javaScript",details:"\n    事件发生时 浏览器调用执行\n    ",latestReview:"",nextReview:"",count:6},{key:"87",word:"字面量创建函数",type:"javaScript",details:"\n    function ninjaFunction() {}\n    ",latestReview:"2020/12/15",nextReview:"2021/1/14",count:5},{key:"88",word:"浏览器执行环境的核心基理",type:"javaScript",details:"\n    单线程模型：同一时刻只能执行一个代码片段\n    ",latestReview:"",nextReview:"",count:6},{key:"89",word:"函数作为函数参数",type:"javaScript",details:"\n    function call(ninjaFunction) {\n      ninjaFunction()\n    }\n    call (function() {})\n    ",latestReview:"",nextReview:"",count:6},{key:"90",word:"为什么出现了事件队列",type:"javaScript",details:"\n    因为单线程模型\n    浏览器需要一种方式来跟踪已经发生但尚未处理的事件\n    ",latestReview:"2020/12/15",nextReview:"2021/1/14",count:10},{key:"91",word:"什么是事件队列",type:"javaScript",details:"\n    所有已生成的事件\n    都会放在同一个事件队列中\n    以他们被浏览器检测到的顺序排列\n\n    tips：事件可能有用户生成的、鼠标移动或键盘挤压、服务器生成（Ajax事件）\n    ",latestReview:"",nextReview:"",count:6},{key:"92",word:"为什么要格外注意处理所有事件的总时间",type:"javaScript",details:"\n    因为执行需要花费大量时间执行的事件处理函数\n    会导致Web应用无响应\n    ",latestReview:"2020/12/15",nextReview:"2021/1/14",count:5},{key:"93",word:"什么是事件处理器（监听器）",type:"javaScript",details:"\n    某个特定事件发生后期望执行的函数\n    ",latestReview:"2020/12/22",nextReview:"2021/1/21",count:5},{key:"94",word:"什么是注册事件处理器（监听器）",type:"javaScript",details:"\n    为了执行期望的函数\n    必须告知浏览器需要处理哪个事件\n    这个过程叫做注册事件处理器\n    ",latestReview:"2020/12/10",nextReview:"2021/1/9",count:5},{key:"95",word:"注册事件方式（两种）",type:"javaScript",details:"\n    ①通过把函数赋值给某个特殊属性\n    ②通过使用内置addEventListener方法\n    ",latestReview:"",nextReview:"",count:6},{key:"96",word:"页面生命周期",type:"基础知识",details:"\n    ①用户输入url\n    ②生成请求并发送至服务器\n    ③执行某些动作或获取某些资源\n        将响应发送回客户端\n    ④处理HTML、CSS和JS并构建结果页面\n    ⑤监控事件队列 一次处理其中一个事件\n    ⑥与页面元素交互\n    ⑦关闭Web页面\n    ",latestReview:"2020/12/29",nextReview:"2021/1/28",count:5},{key:"97",word:"页面构建阶段的目标 两个步骤",type:"基础知识",details:"\n    建立Web应用的UI\n\n    ①解析HTML代码并构建文档对象模型（DOM）\n    ②执行JavaScript代码\n    ",latestReview:"2020/12/22",nextReview:"2021/1/21",count:5},{key:"98",word:"构建阶段两个步骤运作理解",type:"基础知识",details:"\n    ①页面构建阶段从浏览器接收页面代码开始\n    ②过程中两个步骤会交替执行多次\n    ③当浏览器遇到脚本元素 会停止从HTML构建DOM\n        开始执行Js代码 \n    ④若DOM还未构建完成则接着构建\n        再次遇到脚本元素周而复始\n        直到处理完所有HTML元素\n    tips：脚本元素用于包括Js代码\n    ",latestReview:"",nextReview:"",count:6},{key:"99",word:"函数注册事件例",type:"javaScript",details:"\n    例1:将一个函数赋给window对象上的特定属性onload\n    window.onload() = function() {}\n    通过以上代码将事件处理器注册到load事件上\n    tips：load事件在DOM就绪并构建完成时触发\n    例2:点击事件注册\n    document.body.onclick = function() {}\n    ",latestReview:"2020/12/28",nextReview:"2021/1/27",count:5},{key:"100",word:"函数注册的缺点",type:"javaScript",details:"\n    对于某个事件只能注册一个事件处理器\n    很容易将上一个事件处理器改写掉\n    ",latestReview:"2020/12/15",nextReview:"2021/1/14",count:10},{key:"101",word:"replace()",type:"javaScript",details:"\n    replace() 方法用于在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串\n    stringObject.replace(regexp/substr, replacement)\n    ",latestReview:"2020/12/15",nextReview:"2021/1/14",count:5},{key:"102",word:"addEventListener方法例",type:"javaScript",details:'\n    click事件注册处理器\n    document.body.addEventListener("click", function() {\n      ...\n    })\n    ',latestReview:"",nextReview:"",count:6},{key:"103",word:"为什么说函数是第一类对象",type:"javaScript",details:"\n    ①函数与对象共存 被视为其它类型的Js对象\n    ②和Js普通的数据类型一样 \n        可被变量引用、以字面量形式声明、作为函数参数传递\n    ③Js拥有对象的所有能力\n    ",latestReview:"2020/12/24",nextReview:"2021/1/23",count:5},{key:"104",word:"什么是函数式编程",type:"javaScript",details:"\n    通过将函数作为第一类对象\n    书写函数式代码来解决问题的编程风格\n    ",latestReview:"",nextReview:"",count:6},{key:"105",word:"什么是第一类对象",type:"javaScript",details:"\n    第一类对象和编程语言中的其他变量拥有同等地位\n    ",latestReview:"",nextReview:"",count:6},{key:"106",word:"面向函数（函数式）编程优势",type:"javaScript",details:"\n    ①能写出更紧凑、更易懂的代码\n    ②可编写高性能的函数\n    ③让代码更容易测试、扩展和维护\n    ",latestReview:"",nextReview:"",count:6},{key:"107",word:"函数和函数式的概念为什么非常重要",type:"javaScript",details:"\n    函数是程序执行过程中的主要模块单元\n    除全局Js代码是在页面构建阶段执行 其它所有脚本代码都在一个函数内执行\n    ",latestReview:"2021/1/21",nextReview:"2021/1/28",count:3},{key:"108",word:"函数与对象相比 特殊之处在于",type:"javaScript",details:"\n    函数是可调用的(invokable)\n    ",latestReview:"",nextReview:"",count:10},{key:"109",word:"为函数增加一个新属性",type:"javaScript",details:'\n    解释\n    let ninjaFunction = function() {}\n    ninjaFunction.ninja = "忍者"\n    ',latestReview:"2020/12/21",nextReview:"2021/1/20",count:10},{key:"110",word:"将某个函数作为参数传入另一个函数意味着什么 前提是什么",type:"javaScript",details:"\n    意味着函数会在应用程序执行的未来某个时间点才执行\n    函数能够作为参数传入函数（第一类对象的特点之一）\n    ",latestReview:"2020/12/23",nextReview:"2021/1/22",count:5},{key:"111",word:"建立回调 理解",type:"javaScript",details:"\n    当建立了一个将在随后调用的函数时\n    无论在事件处理阶段通过浏览器还是通过其它代码\n    都是在建立一个回调\n    ",latestReview:"",nextReview:"",count:10},{key:"112",word:"回调函数 术语理解",type:"javaScript",details:"\n    建立的函数会在未来的某个时间点“再回来调用”\n    ",latestReview:"2020/12/25",nextReview:"2021/1/24",count:5},{key:"113",word:"什么是回调函数 本质",type:"javaScript",details:"\n    如果把函数的指针（地址）作为参数传递给另一个函数\n    当这个指针被用来调用其所指向的函数时\n    我们就说这是回调函数\n    即：回调函数就是一个通过函数指针调用的函数\n    ",latestReview:"2020/12/25",nextReview:"2021/1/24",count:5},{key:"114",word:"回调函数的特点",type:"javaScript",details:"\n    回调函数不是由该函数的实现方直接调用\n    而是在特定的事件或条件发生时由另外的一方调用\n    用于对该事件或条件进行响应\n    ",latestReview:"2020/12/26",nextReview:"2021/1/25",count:5},{key:"115",word:"手写 以参数形式定义回调函数 能这样做是因为",type:"javaScript",details:"\n    function test(callback) {\n      return callback()\n    }\n    console.log(test(function() { return '参数回调函数' } ))\n    可以在表达式出现的任意位置创建函数\n    （Js的重要特征之一）\n    tips:该例是自己的代码调用自己的回调\n    ",latestReview:"",nextReview:"",count:6},{key:"116",word:"浏览器调用回调函数 例",type:"javaScript",details:'\n    addEventListener方法\n    document.body.addEventListener("click", function() {\n      ...\n    })\n    ',latestReview:"2020/12/23",nextReview:"2021/1/22",count:5},{key:"117",word:"函数作为对象给其添加属性的用途",type:"javaScript",details:"\n    ①存储函数 管理相关联函数\n    ②让函数记住上次计算得到的值 提高后续调用性能\n    ",latestReview:"2020/12/28",nextReview:"2021/1/27",count:5},{key:"118",word:"Js定义函数的方式",type:"javaScript",details:"\n    ①函数声明 && 函数表达式\n    ②箭头函数\n    ③函数构造函数\n    ④生成器函数\n    ",latestReview:"",nextReview:"",count:6},{key:"119",word:"为什么要理解函数不同的定义方式",type:"javaScript",details:"\n    函数的创建方式很大程度影响了\n    ①函数可被调用的时间\n    ②函数的行为\n    ③函数可以在哪个对象上被调用\n    ",latestReview:"2020/12/30",nextReview:"2021/1/29",count:10},{key:"120",word:"函数声明的特征",type:"javaScript",details:"\n    ①以强制性的funciton开头\n    ②关键字后跟着强制性的函数名\n    ③括号以及其中一系列参数名\n    ④函数体必须包括在花括号内\n    ",latestReview:"2020/12/25",nextReview:"2021/1/24",count:5},{key:"121",word:"什么是主机",type:"基础知识",details:"\n    与网络相连的计算机\n    ",latestReview:"2020/12/24",nextReview:"2021/1/23",count:10},{key:"122",word:"函数表达式的特征",type:"javaScript",details:"\n    作为其它表达式的一部分的函数(作为右值 或 作为参数)\n    ",latestReview:"2020/12/11",nextReview:"2021/1/10",count:5},{key:"123",word:"函数表达式 例",type:"javaScript",details:"\n    let a = 3 → let a = test()  // 作为右值\n    myFunction(3) → myFunction(test() {})  //作为参数\n    ",latestReview:"2020/12/24",nextReview:"2021/1/23",count:5},{key:"124",word:"函数声明与函数表达式的不同点",type:"javaScript",details:"\n    ①在代码中的位置不同\n    ②函数声明必须有函数名 函数表达式则可选\n    ③函数表达式使用前必须先赋值\n    ",latestReview:"2020/12/21",nextReview:"2021/1/5",count:4},{key:"125",word:"函数表达式 未先赋值 报错例",type:"javaScript",details:"\n    add(1,2) //无弹窗，报错： add is not a function  \n    let add = function(x, y) {  \n        alert(x + y)  \n    } \n    ",latestReview:"2021/1/21",nextReview:"2021/2/20",count:5},{key:"126",word:"计算机网络中 带宽表示",type:"基础知识",details:"\n    网络中某通道传送数据的能力\n    在单位时间内网络中某信道所能通过的最高数据率\n    ",latestReview:"",nextReview:"",count:6},{key:"127",word:"函数声明为什么必须有函数名",type:"javaScript",details:"\n    因为一个函数的基本要求是能够被调用\n    这意味着它必须有一种被引用的方式\n    这个方式就是通过其名字\n    ",latestReview:"2020/12/25",nextReview:"2021/1/24",count:5},{key:"128",word:"函数内部属性[[Scope]]",type:"javaScript",details:"\n    函数对象和其它对象一样\n    拥有可以通过代码访问的属性和一系列仅供JavaScript引擎访问的内部属性\n    由ECMA-262标准第三版定义\n    该内部属性包含了函数「被创建的作用域中」对象的集合\n    这个集合被称为函数的作用域链，它决定了哪些数据能被函数访问\n\n    注意：\n    函数内部的[[scope]]属性实际访问时访问不到\n    仅供JavaScript引擎访问\n    该属性让我们更好的理解函数\n\n    图像理解：\n    1、函数内部有个「老祖」拥有「链条法宝」 <- [[scope]] 作用域链\n    2、「函数创建时」老祖使用「链条」捕捉「元宝」 <- 创建时函数作用域内可访问的对象\n    3、被捕获的元宝可以被函数享用 <- 决定了哪些数据能被函数访问\n    ",latestReview:"2021/1/26",nextReview:"2021/2/25",count:5},{key:"129",word:"函数表达式为什么可以没有函数名",type:"javaScript",details:"\n    因为函数表达式是其它Js语句的一部分\n    因此有了调用的替代方案\n    ",latestReview:"",nextReview:"",count:6},{key:"130",word:"函数表达式被赋值给一个变量 如何调用函数",type:"javaScript",details:"\n    通过该变量调用该函数\n    let doNothing = function() {}\n    doNothing()\n    ",latestReview:"2020/12/25",nextReview:"2021/1/24",count:5},{key:"131",word:"函数表达式为函数参数",type:"javaScript",details:"\n    在该函数中通过相应的参数名调用\n    function doSomething(action) {\n      action()\n    }\n    ",latestReview:"2020/12/25",nextReview:"2021/1/24",count:5},{key:"132",word:"手写 立即函数",type:"javaScript",details:"\n    console.log((function(a) {\n      return a + 5\n    })(3))\n    与标准函数调用对比\n    function calcTest(a) {\n      return a + 3\n    }\n    console.log(calcTest(3)) \n    ",latestReview:"2020/12/25",nextReview:"2021/1/24",count:5},{key:"133",word:"立即函数特点",type:"javaScript",details:"\n    ①在定义的时候就立即执行\n    ②执行完以后就释放 包括函数内部的所有变量\n    ",latestReview:"2020/12/26",nextReview:"2021/1/25",count:5},{key:"134",word:"立即函数的优点",type:"javaScript",details:"\n    ①不需要函数名\n    ②可在浏览器控制台直接得到结果\n    ",latestReview:"2020/12/27",nextReview:"2021/1/26",count:10},{key:"135",word:"什么是匿名函数",type:"javaScript",details:"\n    没有名字的函数\n    ",latestReview:"2020/12/25",nextReview:"2021/1/24",count:5},{key:"136",word:"匿名函数 例",type:"javaScript",details:'\n    function(a, b) {\n      console.log("a = " + a);\n      console.log("b = " + b);\n    }\n    ',latestReview:"2020/12/25",nextReview:"2021/1/24",count:5},{key:"137",word:"匿名函数如何使用",type:"javaScript",details:'\n    依附于一个变量\n    let test = function(a, b) {\n      console.log("a = " + a);\n      console.log("b = " + b);\n    }\n    此时变量名就是这个匿名函数的名字\n    ',latestReview:"",nextReview:"",count:6},{key:"138",word:"什么是数据率（data rate）",type:"基础知识",details:"\n    数据的传送速率\n    ",latestReview:"2020/12/30",nextReview:"2021/1/29",count:5},{key:"139",word:"匿名函数与立即函数的关系",type:"javaScript",details:"\n    匿名函数外加一层括号→变成表达式\n    之后再加一个括号（参数）变成立即函数\n    ",latestReview:"2020/12/25",nextReview:"2021/1/24",count:5},{key:"140",word:"箭头函数的优点",type:"javaScript",details:"\n    不会产生任何因为书写function关键字、大括号或return导致混乱\n    ",latestReview:"",nextReview:"",count:6},{key:"141",word:"如果箭头函数的函数体是一个表达式 那么其返回值是",type:"javaScript",details:"\n    箭头函数体表达式的值\n    ",latestReview:"2020/12/25",nextReview:"2021/1/24",count:10},{key:"142",word:"判断this思路",type:"javaScript",details:"\n    首先寻找this位置：\n    在全局作用域中 -> this指向window\n    在class中 -> this指向新创建的类实例\n    在函数foo中 -> 判断函数类型：\n    ①箭头函数：this指向包裹箭头函数的第一个普通函数\n    ②call、bind、apply：this被强绑定在指定对象上\n    ③普通函数：看函数如何被调用：\n      1）foo()还是obj.foo() ? \n        foo()：this指向window\n        obj.foo()：this指向obj\n      2）new方式：this指向new出来的实例\n    ",imgList:["key142.jpg"],latestReview:"2020/12/28",nextReview:"2021/1/27",count:5},{key:"143",word:"函数对象拥有哪两个属性",type:"javaScript",details:"\n    函数对象拥有prototype属性和__proto__属性\n    ",latestReview:"",nextReview:"",count:6},{key:"144",word:"prototype属性",type:"javaScript",details:"\n    JS设计之初为了实现简单继承，引入了prototype属性，也叫原型对象（显式原型）\n    ",latestReview:"2020/12/28",nextReview:"2021/1/27",count:5},{key:"145",word:"__proto__属性",type:"javaScript",details:"\n    所有的对象obj(null和undefined除外)都具有__proto__属性（隐式原型）\n    __proto__属性在本质上为一个指针，指向函数对象的prototype属性\n\n    var student = new Person();\n    console.log(student.__proto__ === Person.prototype); // true\n    ",latestReview:"2020/12/28",nextReview:"2021/1/27",count:5},{key:"146",word:"什么是原型链",type:"javaScript",details:"\n    原型链是JS中实现继承的主要方法\n    其基本思想就是让一个引用类型继承另一个引用类型的属性和方法\n    ",latestReview:"2020/12/18",nextReview:"2021/1/17",count:5},{key:"147",word:"什么是webpack",type:"webpack",details:"\n    webpack是模块打包工具\n    将多个模块打包到生成一个最终的bundle.js\n    ",latestReview:"2020/12/28",nextReview:"2021/1/27",count:5},{key:"148",word:"package.json文件作用",type:"webpack",details:"\n    描述了node项目\n    npm init 生成的就是一个package.json文件\n    ",latestReview:"2020/12/29",nextReview:"2021/1/28",count:5},{key:"149",word:"package.json基本属性说明",type:"webpack",details:"\n    name - 包名.\n    version - 包的版本号。\n    description - 包的描述。\n    homepage - 包的官网URL。\n    author - 包的作者，它的值是你在https://npmjs.org网站的有效账户名，遵循“账户名<邮件>”的规则\n             例如：zhangsan <zhangsan@163.com>。\n    contributors - 包的其他贡献者。\n    dependencies / devDependencies - 生产/开发环境依赖包列表。它们将会被安装在 node_module 目录下。\n    main - main 字段指定了程序的主入口文件，require('moduleName') 就会加载这个文件。\n    该字段的默认值是模块根目录下面的 index.js。\n    keywords - 关键字\n    ",latestReview:"",nextReview:"",count:6},{key:"150",word:"webpack两种环境及其区别",type:"webpack",details:"\n    主要分为development和production两种环境\n    默认情况下是production环境\n    两者的区别是 production会对打包后的文件压缩\n    ",latestReview:"2020/12/29",nextReview:"2021/1/28",count:10},{key:"151",word:"什么是loader",type:"webpack",details:"\n    Webpack 本身只能处理 JavaScript 模块\n    如果要处理其他类型的文件，就需要使用 loader 进行转换\n    loader是一个打包的方案\n    它知道对于某个特定的文件该如何去打包\n    比如图片，字体图标的模块，webpack不知道如何打包\n    ",latestReview:"2020/12/29",nextReview:"2021/1/28",count:5},{key:"152",word:"js获取原型的方法",type:"javaScript",details:"\n    1、p.__proto__\n    2、p.constructor.prototype\n      p.constructor即相当于函数实例\n      因为若实p中没有constructor属性 则会搜索p的原型对象\n      而原型对象中的constructor指向函数实例\n      函数实例的prototype属性指向原型对象\n    3、Object.getPrototypeOf(p)\n    ",imgList:["key152-1.jpg"],latestReview:"2021/1/22",nextReview:"2021/1/23",count:0},{key:"153",word:"什么是闭包",type:"javaScript",details:"\n    闭包是指有权访问另一个函数作用域内变量的函数\n    ",latestReview:"",nextReview:"",count:6},{key:"154",word:"闭包常用的两个用途",type:"javaScript",details:"\n    闭包的第一个用途是使我们在函数外部能够访问到函数内部的变量。\n    通过使用闭包，我们可以通过在外部调用闭包函数，从而在外部访问到函数内部的变量，可以使用这种方法来创建私有变量。\n\n    函数的另一个用途是使已经运行结束的函数上下文中的变量对象继续留在内存中，\n    因为闭包函数保留了这个变量对象的引用，所以这个变量对象不会被回收\n    ",latestReview:"",nextReview:"",count:6},{key:"155",word:"闭包基本例",type:"javaScript",details:"\n    function a() {\n      var n = 0;\n      function add(){\n        n++;\n        console.log(n);\n      }\n      return add;\n    }\n    var a1 = a(); //注意，函数名只是一个标识（指向函数的指针），而（）才是执行函数；\n    a1();    //1\n    a1();    //2  第二次调用n变量还在内存中\n    ",latestReview:"2020/12/18",nextReview:"2021/1/17",count:5},{key:"156",word:"DOM理解",type:"javaScript",details:"\n    文档对象模型\n    它指的是把文档当做一个对象来对待，这个对象主要定义了处理网页内容的方法和接口\n    ",latestReview:"2020/12/21",nextReview:"2021/1/20",count:5},{key:"157",word:"BOM理解",type:"javaScript",details:"\n    浏览器对象模型\n    它指的是把浏览器当做一个对象来对待，这个对象主要定义了与浏览器进行交互的方法和接口\n    ",latestReview:"",nextReview:"",count:6},{key:"158",word:"BOM的核心是",type:"javaScript",details:"\n    BOM的核心是window\n    ",latestReview:"",nextReview:"",count:6},{key:"159",word:"window对象的双重角色 意味着什么",type:"javaScript",details:"\n    它既是通过 js 访问浏览器窗口的一个接口，又是一个 Global（全局） 对象。\n    这意味着在网页中定义的任何对象，变量和函数，都作为全局对象的一个属性或者方法存在\n    ",latestReview:"",nextReview:"",count:6},{key:"160",word:"正则表达式的作用",type:"javaScript",details:"\n    正则表达式是一门工具 \n    目的是为了字符串模式匹配 从而实现搜索和替换功能\n    ",latestReview:"",nextReview:"",count:6},{key:"161",word:"正则表达式的基本组成元素",type:"javaScript",details:"\n    字符和元字符\n\n    字符：基础的计算机字符编码，通常正则表达式里面使用的就是数字、英文字母\n    元字符：特殊字符，是一些用来表示特殊语义的字符 如^表示非 |表示或等\n    ",latestReview:"2020/12/7",nextReview:"2021/1/6",count:5},{key:"162",word:"什么是生成器",type:"javaScript",details:"\n    生成器是一种特殊类型的函数\n    标准函数：当从头到尾运行标准函数时 最多只生成一个值\n    生成器函数：会在几次运行请求中暂停 每次运行都可能会生成一个值\n    ",latestReview:"",nextReview:"",count:6},{key:"163",word:"时延（delay或latency）",type:"基础知识",details:"\n    时延（delay或latency）\n    数据从网络的一端传送到另一端所需的时间\n    ",latestReview:"",nextReview:"",count:6},{key:"164",word:"调用生成器并不会",type:"javaScript",details:"\n    并不会执行生成器函数\n    相反 会创建一个叫做迭代器的对象\n    ",latestReview:"2020/12/7",nextReview:"2021/1/6",count:5},{key:"165",word:"yield作用",type:"javaScript",details:"\n    使用yield对象生成独立的值\n    ",latestReview:"2020/12/19",nextReview:"2021/1/18",count:5},{key:"166",word:"迭代器的作用",type:"javaScript",details:"\n    迭代器用于控制生成器的执行\n    迭代器暴露的最基本接口是next()方法\n    该方法可以用来向生成器请求一个值\n    ",latestReview:"",nextReview:"",count:6},{key:"167",word:"迭代器 next方法作用 返回值",type:"javaScript",details:"\n    该方法可以用来向生成器请求一个值\n    返回一个携带着生成值的对象\n    该对象中包含的done属性指示了生成器是否还会追加生成值\n    ",latestReview:"",nextReview:"",count:6},{key:"168",word:"function签名的async意味着什么",type:"微信小程序",details:"\n    意味着当前函数依赖一个异步返回的值\n    在每个调用异步的位置上\n    都要放置一个await关键字用来告诉Js引擎：\n    在不阻塞应用执行的情况下在这个位置上等待执行结果\n    ",latestReview:"",nextReview:"",count:6},{key:"169",word:"在微信小程序中JSON的作用是",type:"微信小程序",details:"\n    静态配置\n    ",latestReview:"",nextReview:"",count:6},{key:"170",word:"app.json是什么",type:"微信小程序",details:"\n    当前微信小程序的全局配置\n    ",latestReview:"2020/12/20",nextReview:"2021/1/19",count:10},{key:"171",word:"app.json包括哪些配置",type:"微信小程序",details:"\n    所有页面路径、界面表现、网络超时时间、底部tab等 \n    ",latestReview:"2020/12/21",nextReview:"2021/1/20",count:10},{key:"172",word:"app.json中pages字段",type:"微信小程序",details:'\n    "pages":[\n      "pages/index/index",\n      "pages/logs/logs"\n    ]\n    pages字段\n    用于描述当前微信小程序所有页面路径\n    为了让微信客户端知道当前你的微信小程序页面定义在哪个目录\n    文件名不需要写文件后缀，框架会自动去寻找对应位置的 .json, .js, .wxml, .wxss 四个文件进行处理\n\n    微信小程序中新增/减少页面，都需要对 pages 数组进行修改\n    ',latestReview:"2020/12/20",nextReview:"2021/1/19",count:10},{key:"173",word:"微信小程序app.json中window字段",type:"微信小程序",details:'\n    "window":{\n      "backgroundTextStyle":"light",\n      "navigationBarBackgroundColor": "#fff",\n      "navigationBarTitleText": "WeChat",\n      "navigationBarTextStyle":"black"\n    }\n    定义微信小程序所有页面的顶部\n    背景颜色\n    文字颜色定义等\n    ',latestReview:"2020/12/19",nextReview:"2021/1/18",count:5},{key:"174",word:"Vue v-once指令的作用",type:"Vue",details:"\n    执行一次性地插值\n    当数据改变时，插值处的内容不会更新\n    ",latestReview:"",nextReview:"",count:6},{key:"175",word:"project.config.json的优点",type:"微信小程序",details:"\n    当重新安装工具或者换电脑工作时\n    只要载入同一个项目的代码包\n    开发者工具会自动恢复到之前的个性化配置\n    ",latestReview:"2020/12/20",nextReview:"2021/1/19",count:10},{key:"176",word:"page.json的作用",type:"微信小程序",details:"\n    独立定义每个页面的属性\n    ",latestReview:"2020/12/20",nextReview:"2021/1/19",count:5},{key:"177",word:"微信小程序JSON语法",type:"微信小程序",details:"\n    1、JSON文件都是被包裹在一个大括号中\n    2、{}通过key-value的方式来表达数据\n    3、JSON的Key必须包裹在一个双引号中\n    ",latestReview:"2020/12/7",nextReview:"2021/1/6",count:10},{key:"178",word:"微信小程序JSON语法易错点",type:"微信小程序",details:"\n    注意点：（常见错误）\n    ①在实践中忘给 Key 值加双引号 \n    ②把双引号写成单引号\n    ",latestReview:"2020/12/20",nextReview:"2021/1/19",count:5},{key:"179",word:"JSON值允许的变量类型 注意点",type:"微信小程序",details:"\n    ①数字，包含浮点数和整数\n    ②字符串，需要包裹在双引号中\n    ③Bool值，true 或者 false\n    ④数组，需要包裹在方括号中 []\n    ⑤对象，需要包裹在大括号中 {}\n    ⑥Null\n    注意点：JSON 文件中无法使用注释试图添加注释将会引发报错\n    ",latestReview:"2020/12/23",nextReview:"2021/1/22",count:5},{key:"180",word:"什么是吞吐量",type:"基础知识",details:"\n    吞吐量（throughput）\n    表示在单位时间内通过某个网络的实际数据量\n    ",latestReview:"2021/1/20",nextReview:"2021/2/19",count:5},{key:"181",word:"HTML CSS在微信小程序中分别对应",type:"微信小程序",details:"\n    HTML -> WXML\n    CSS -> WXSS\n    ",latestReview:"",nextReview:"",count:6},{key:"182",word:"HTML与WXML的区别",type:"微信小程序",details:"\n    ①标签名字不同 （WXML）中的标签被封装成各种功能组件\n    ②多了条件控制语句wx:if 以及数据绑定 {{ }} \n    ",latestReview:"",nextReview:"",count:6},{key:"183",word:"微信小程序 {{ }} 语法的作用",details:"\n    把一个变量绑定到界面上 称为数据绑定\n    ",latestReview:"2020/12/5",nextReview:"2021/1/4",count:5},{key:"184",word:"WXML全称",type:"微信小程序",details:"\n    WeiXin Markup Language\n    ",latestReview:"2020/12/2",nextReview:"2021/1/1",count:5},{key:"185",word:"WXML 基本数据绑定",type:"微信小程序",details:"\n    \x3c!--wxml--\x3e\n    <view> {{message}} </view>\n    // page.js\n    Page({\n      data: {\n        message: 'Hello MINA!'\n      }\n    })\n    ",latestReview:"",nextReview:"",count:6},{key:"186",word:"WXML 基本列表渲染",type:"微信小程序",details:'\n    \x3c!--wxml--\x3e\n    <view wx:for="{{array}}"> {{item}} </view>\n    // page.js\n    Page({\n      data: {\n        array: [1, 2, 3, 4, 5]\n      }\n    })\n    ',latestReview:"",nextReview:"",count:6},{key:"187",word:"WXML 基本条件渲染",type:"微信小程序",details:"\n    \x3c!--wxml--\x3e\n    <view wx:if=\"{{view == 'WEBVIEW'}}\">WEBVIEW </view>\n    <view wx:elif=\"{{view == 'APP'}}\"> APP </view>\n    <view wx:else=\"{{view == 'MINA'}}\"> MINA </view>\n    // page.js\n    Page({\n      data: {\n        view: 'MINA'\n      }\n    })\n    ",latestReview:"",nextReview:"",count:6},{key:"188",word:"hover-class是什么",type:"微信小程序",details:"\n    导航按钮点击样式效果\n    ",latestReview:"2020/12/2",nextReview:"2021/1/1",count:5},{key:"189",word:"app.json中entryPagePath字段",type:"微信小程序",details:'\n    指定微信小程序的默认启动路径（首页）\n    常见情景是从微信聊天列表页下拉启动、微信小程序列表启动等。\n    如果不填，将默认为 pages 列表的第一项。\n    不支持带页面路径参数\n\n    {\n      "entryPagePath": "pages/index/index"\n    }\n    ',latestReview:"",nextReview:"",count:6},{key:"190",word:"app.json中subpackages字段",type:"微信小程序",details:"\n    分包结构配置\n    ",latestReview:"2021/1/20",nextReview:"2021/1/27",count:3},{key:"191",word:"app.json中usingComponents字段",type:"微信小程序",details:"\n    全局自定义组件配置\n    ",latestReview:"2020/12/5",nextReview:"2021/1/4",count:5},{key:"192",word:"什么是场景值",type:"微信小程序",details:"\n    场景值用来描述用户进入微信小程序的路径\n    ",latestReview:"2020/12/4",nextReview:"2021/1/3",count:5},{key:"193",word:"WXML模版是什么",type:"微信小程序",details:"\n    WXML提供模板（template），可以在模板中定义代码片段，然后在不同的地方调用\n    ",latestReview:"",nextReview:"",count:6},{key:"194",word:"注册微信小程序",type:"微信小程序",details:"\n    每个微信小程序都需要在 app.js 中调用 App 方法注册微信小程序实例\n    绑定生命周期回调函数、错误监听和页面不存在监听函数等\n    ",latestReview:"2021/1/19",nextReview:"2021/2/18",count:5},{key:"195",word:"Babel如何处理JSX",type:"微信小程序",details:"\n    Babel 会把 JSX 转译成一个名为 React.createElement() 函数调用\n    ",latestReview:"2020/12/20",nextReview:"2021/1/4",count:4},{key:"196",word:"注册微信小程序 App方法",type:"微信小程序",details:"\n    // app.js\n    App({\n      onLaunch (options) {\n        // Do something initial when launch.\n      },\n      onShow (options) {\n        // Do something when show.\n      },\n      onHide () {\n        // Do something when hide.\n      },\n      onError (msg) {\n        console.log(msg)\n      },\n      globalData: 'I am global data'\n    })\n\n    整个微信小程序只有一个 App 实例，是全部页面共享的。\n    开发者可以通过 getApp 方法获取到全局唯一的 App 实例\n    获取App上的数据或调用开发者注册在 App 上的函数\n    ",latestReview:"2021/1/21",nextReview:"2021/2/20",count:5},{key:"197",word:"获取全局app实例中的数据",type:"微信小程序",details:"\n    / xxx.js\n    const appInstance = getApp()\n    console.log(appInstance.globalData) // I am global data\n    ",latestReview:"2020/12/23",nextReview:"2021/1/22",count:5},{key:"198",word:"Page对象-onLoad方法",type:"微信小程序",details:"\n    页面加载时触发\n    一个页面只会调用一次，可以在 onLoad 的参数中获取打开当前页面路径中的参数\n    参数为query\n    ",latestReview:"",nextReview:"",count:0},{key:"199",word:"Page对象-onShow方法",type:"微信小程序",details:"\n    页面显示/切入前台时触发\n    ",latestReview:"2021/1/19",nextReview:"2021/1/20",count:0},{key:"200",word:"Page对象-onHide方法",type:"微信小程序",details:"\n    页面隐藏/切入后台时触发\n    如 wx.navigateTo 或底部 tab 切换到其他页面，小程序切入后台等\n    参数为query\n    ",latestReview:"",nextReview:"",count:0},{key:"201",word:"微信小程序路由由什么管理 以什么形式管理",type:"微信小程序",details:"\n    在微信小程序中所有页面的路由全部由框架进行管理\n    框架以栈的形式维护了当前的所有页面\n    ",latestReview:"2020/12/23",nextReview:"2021/1/22",count:5},{key:"202",word:"与 CSS 相比，WXSS 扩展的特性有",type:"微信小程序",details:"\n    尺寸单位\n    样式导入\n    ",latestReview:"2020/12/21",nextReview:"2021/1/20",count:5},{key:"203",word:"rpx单位理解",type:"微信小程序",details:"\n    微信小程序的屏幕宽度固定为750rpx 在所有设备上都如此\n    1rpx = (screenWidth/750)px screenWidth为手机屏幕的实际宽度（px）\n\n    如iphone6 screenWidth为375px 则在iphone6中1rpx = 0.5px\n    样式导入\n    ",latestReview:"",nextReview:"",count:6},{key:"204",word:"微信小程序导入外联样式表 📖",type:"微信小程序",details:'\n    使用@import语句可以导入外联样式表\n    @import后跟需要导入的外联样式表的相对路径\n    用;表示语句结束\n\n    /** common.wxss **/\n    .small-p {\n      padding:5px;\n    }\n\n    /** app.wxss **/\n    @import "common.wxss";\n    .middle-p {\n      padding:15px;\n    }\n    ',latestReview:"",nextReview:"",count:6},{key:"205",word:"微信小程序 什么是事件",type:"微信小程序",details:"\n    事件是视图层到逻辑层的通讯方式\n    ",latestReview:"2020/12/20",nextReview:"2021/1/19",count:5},{key:"206",word:"getCurrentPages()方法作用",type:"微信小程序",details:"\n    获取当前页面栈\n    ",latestReview:"2020/12/21",nextReview:"2021/1/20",count:5},{key:"207",word:"Vue导航守卫三个参数",type:"Vue",details:"\n    to: Route: 即将要进入的目标 路由对象\n    from: Route: 当前导航正要离开的路由\n    next: Function: 一定要调用该方法来 resolve 这个钩子。执行效果依赖 next 方法的调用参数\n    ",latestReview:"2020/12/20",nextReview:"2021/1/19",count:5},{key:"208",word:"什么是节流",type:"javaScript",details:"\n    规定一个时间n，n秒内，将触发的事件合并为一次并执行\n\n    理解例 电梯等第一个人进来之后，5秒后准时运作，不等待，若5秒内还有人进来，也不重置\n    ",latestReview:"2020/12/20",nextReview:"2021/1/19",count:5},{key:"209",word:"Vue计算属性缘何而来",type:"Vue",details:"\n    模板内的表达式非常便利，但是设计它们的初衷是用于简单运算的。\n    在模板中放入太多的逻辑会让模板过重且难以维护\n    例如：\n    <div id=\"example\">\n      {{ message.split('').reverse().join('') }}\n    </div>\n    ",latestReview:"2020/12/20",nextReview:"2021/1/19",count:5},{key:"210",word:"节流使用场景",type:"javaScript",details:"\n    resize，touchmove移动DOM，上拉列表加载数据等\n    ",latestReview:"2020/12/31",nextReview:"2021/1/15",count:4},{key:"211",word:"resize",type:"CSS",details:"\n    CSS3 resize 属性 规定可以由用户调整 div 元素的大小\n    div\n    {\n      resize:both;\n      overflow:auto;\n    }\n\n    none\t用户无法调整元素的尺寸\n    both\t用户可调整元素的高度和宽度\n    horizontal\t用户可调整元素的宽度\n    vertical\t用户可调整元素的高度\n    ",latestReview:"2021/1/21",nextReview:"2021/2/20",count:5},{key:"212",word:"touchmove",type:"javaScript",details:"\n    touchmove事件:当手指在屏幕上滑动的时候连续地触发\n    ",latestReview:"2020/12/23",nextReview:"2021/1/22",count:10},{key:"213",word:"基本防抖函数",type:"javaScript",details:"\n    debounce(fn, delay) {\n      let timer = null\n      return function() {\n        if (timer) {\n          clearTimeout(timer)\n        }\n        timer = setTimeout(fn, delay)\n      }\n    }\n    ",latestReview:"2020/12/16",nextReview:"2021/1/15",count:10},{key:"214",word:"微信小程序 事件的作用（抽象理解）",type:"微信小程序",details:"\n    事件可以将用户的行为反馈到逻辑层进行处理\n    事件可以绑定在组件上，当达到触发事件，就会执行逻辑层中对应的事件处理函数\n    ",latestReview:"2020/12/4",nextReview:"2021/1/3",count:5},{key:"215",word:"微信小程序 基本事件绑定 📖",type:"微信小程序",details:'\n    如bindtap，当用户点击该组件的时候会在该页面对应的Page中找到相应的事件处理函数\n    <view id="tapTest" data-hi="Weixin" bindtap="tapName"> Click me! </view>\n\n    在相应的Page定义中写上相应的事件处理函数，参数是event。\n    Page({\n      tapName: function(event) {\n        console.log(event)\n      }\n    })\n    ',latestReview:"2020/12/25",nextReview:"2021/1/24",count:5},{key:"216",word:"快捷指令 imp",type:"工作经验",details:"\n    import fs from 'fs'\n    ",latestReview:"2020/12/4",nextReview:"2021/1/3",count:10},{key:"217",word:"快捷指令 imd",type:"工作经验",details:"\n    import { function } from 'fs'\n    ",latestReview:"2020/12/14",nextReview:"2021/1/13",count:5},{key:"218",word:"快捷指令 ime",type:"工作经验",details:"\n    import * as localAlias from 'fs'\n    ",latestReview:"2020/12/11",nextReview:"2021/1/10",count:5},{key:"219",word:"快捷指令 thenc",type:"工作经验",details:"\n    .then((res) => {})\n    .catch((err) => {})\n    ",latestReview:"2020/12/11",nextReview:"2021/1/10",count:10},{key:"220",word:"微信小程序view scroll-view",type:"微信小程序",details:"\n    view 基本视图容器 相当于div\n    scroll-view 可滚动视图区域\n    ",latestReview:"2020/12/11",nextReview:"2021/1/10",count:10},{key:"221",word:"微信小程序hover-class",type:"微信小程序",details:'\n    指定按下去的样式类。当 hover-class="none" 时，没有点击态效果\n    ',latestReview:"2020/12/11",nextReview:"2021/1/10",count:5},{key:"222",word:"微信小程序swiper swiper-item",type:"微信小程序",details:"\n    swiper 滑块视图容器。其中只可放置swiper-item组件，否则会导致未定义的行为\n    swiper-item 仅可放置在swiper组件中，宽高自动设置为100%\n    ",latestReview:"",nextReview:"",count:6},{key:"223",word:"Vue v-model指令的作用",type:"Vue",details:"用于表单数据与data的双向绑定",latestReview:"",nextReview:"",count:0},{key:"224",word:"微信小程序 使用vant组件 📖",type:"微信小程序",details:'\n    页面json配置中 定义usingComponents\n    "usingComponents": {\n      "van-grid": "@vant/weapp/grid/index",\n      "van-grid-item": "@vant/weapp/grid-item/index"\n    }\n    ',latestReview:"2020/12/11",nextReview:"2021/1/10",count:5},{key:"225",word:"微信小程序 getApp",type:"微信小程序",details:"\n    获取到小程序全局唯一的 App 实例\n    //获取应用实例\n    const app = getApp()\n\n    不要在定义于 App() 内的函数中，或调用 App 前调用 getApp() ，使用 this 就可以拿到 app 实例\n    ",latestReview:"2020/12/26",nextReview:"2021/1/25",count:10},{key:"226",word:"微信小程序 wx.getUserInfo",type:"微信小程序",details:"\n    获取用户信息\n    ",latestReview:"2020/12/11",nextReview:"2021/1/10",count:5},{key:"227",word:"Css height:100% 坑",type:"CSS",details:"\n    一个元素高度是否可以使用百分比显示，取决于其父级对象\n    #id的父级是body，而浏览器默认状态下，是没有给body一个高度属性的\n    因此当我们直接设置#id为height:100%;时，不会产生任何效果\n    ",latestReview:"",nextReview:"",count:6},{key:"228",word:"Vue mixin是什么",type:"Vue",details:"\n    混入 (mixin) \n    提供了一种非常灵活的方式，来分发 Vue 组件中的可复用功能\n    ",latestReview:"2021/1/19",nextReview:"2021/1/26",count:3},{key:"229",word:"VsCode快捷键 转到文件",type:"工作经验",details:"\n    command + p\n    ",latestReview:"2020/12/11",nextReview:"2021/1/10",count:5},{key:"230",word:"VsCode快捷键 重新打开最新关闭的窗口",type:"工作经验",details:"\n    command + shift + t\n    ",latestReview:"",nextReview:"",count:6},{key:"231",word:"扩展运算符 作为函数参数",type:"javaScript",details:"\n    let num = [1, 2, 3, 4, 5]\n    Math.max(...num)  // 5\n    ",latestReview:"",nextReview:"",count:6},{key:"232",word:"抓取对象属性定义简写",type:"javaScript",details:"\n    testObj: {\n      name: 'zcb',\n      age: '23',\n      video: '斗罗大陆',\n      favorite: '唐三'\n    }\n\n    getInfo(obj) {\n      const { video, favorite } = obj\n      this.info1 = video\n      this.info2 = favorite\n    }\n    ",latestReview:"2020/12/25",nextReview:"2021/1/24",count:5},{key:"233",word:"Vue template调试",type:"Vue",details:"\n    ①created()方法中添加console方法\n    this.$logs = window.console.log\n\n    ②在template中使用\n    {{ $logs(变量) }}\n    ",latestReview:"2020/12/25",nextReview:"2021/1/24",count:5},{key:"234",word:"Vue 监听对象中的属性 优化写法",type:"Vue",details:"\n    watch: {\n      'obj.a': {\n        handler(nVal, oVal) {\n          ...\n        }\n      }\n    }\n    ",latestReview:"2020/12/25",nextReview:"2021/1/24",count:10},{key:"235",word:"nextTick作用 新理解",type:"Vue",details:"\n    vue实现响应式并不是数据发生变化后dom立即变化\n    而是按照一定的策略来更新dom\n\n    nextTick是在下次DOM更新循环结束之后执行 延迟回调\n    在修改数据之后使用nextTick 则可在回调中获取更新后的DOM\n    ",latestReview:"",nextReview:"",count:6},{key:"236",word:"Vue 具名插槽 📖",type:"Vue",details:'\n    子组件\n    <solt :name="xxx"></solt>\n\n    父组件\n    <template v-slot:xxx>\n      <a-button type="primary">地址</a-button>\n    </template>\n    ',latestReview:"",nextReview:"",count:6},{key:"237",word:"Vue 带参具名插槽 📖",type:"Vue",details:'\n    子组件\n    <slot :name="xxx" :data="xxData"></slot>\n\n    父组件\n    <template v-slot:xxx="xxx">\n      <a-button type="primary" @click="getData(xxx)">地址</a-button>\n    </template>\n    ',latestReview:"2020/12/11",nextReview:"2021/1/10",count:5},{key:"238",word:"Vue 什么时候应该使用计算属性",type:"Vue",details:"\n    对于任何复杂逻辑，你都应当使用计算属性\n    ",latestReview:"2020/12/15",nextReview:"2021/1/14",count:10},{key:"239",word:"Vue子组件 对象默认值 default 📖",type:"Vue",details:"\n    props: {\n      xxObj: {\n        type: Object,\n        default: function() {\n          return {\n            属性1: '',\n            属性2: '',\n              ...\n          }\n        }\n      }\n    }\n    ",latestReview:"",nextReview:"",count:6},{key:"240",word:"Vue计算属性返回对象 某属性需大量判断",type:"Vue",details:'\n    使用立即函数+闭包破局\n\n    例：动态返回style\n    <div\n      class="td"\n      :style="tdStyle(tdProp)"\n      v-for="(tdItem, tdProp) in item"\n      :key="tdItem"\n      ref="tdEach"\n    >\n\n    tdStyle() {\n      return function(prop) {\n        let _this = this\n        return {\n          textAlign: this.styleConfig.bodyTestPosition,\n          width: (function(prop) {\n            let width = \'\'\n            _this.headerConfig.map(item => {\n              (item.prop === prop) && (width = ‘¥{item.width}px’)\n            })\n            return width\n          })(prop)\n        }\n      }\n    },\n    ',latestReview:"2020/12/25",nextReview:"2021/1/24",count:5},{key:"241",word:"React的核心库是",type:"React",details:"\n    react.js库\n    ",latestReview:"2020/12/7",nextReview:"2021/1/6",count:10},{key:"242",word:"React的的一切基于",type:"React",details:"\n    React的一切基于组件\n    使用React，唯一要关心的就是构建组件\n    各个组件有各自的状态，状态变更时，会自动重新渲染组件\n    ",latestReview:"2020/12/7",nextReview:"2021/1/6",count:5},{key:"243",word:"React基本组件 基本例",type:"React",details:"\n    // Profile.jsx\n    import React from 'react';\n    export default Class Profile extends React.Component {\n      render() {\n        return (\n          <div>Hello World</div>\n        )\n      }\n    }\n    ",latestReview:"",nextReview:"",count:10},{key:"244",word:"React引用组件 基本例",type:"React",details:"\n    import Profile from './profile';\n\n    export default function(props) {\n      return (\n        <Profile />\n      )\n    }\n    ",latestReview:"",nextReview:"",count:10},{key:"245",word:"什么是JSX",type:"React",details:"\n    是一个 JavaScript 的语法扩展\n    把HTML嵌套在JS中的写法被称作JSX\n    运行时，Babel等工具会将JSX编译成JavaScript语法\n    ",latestReview:"2020/12/21",nextReview:"2021/1/5",count:4},{key:"246",word:"使用纯JSON对象描述HTML元素",type:"React",details:"\n    现在需要描述一个按钮（button）HTML语法如下\n    <button class=\"btn btn-blue\">\n      <em>Confirm</em>\n    </button>\n\n    我们可以用这样一个JSON对象去表达这个按钮\n    {\n      type: 'button',\n      props: {\n        className: 'btn btn-blue',\n        children: {\n          type: 'em',\n          props: {\n            children: 'Confirm'\n          }\n        }\n      }\n    }\n    ",latestReview:"2020/12/21",nextReview:"2021/1/20",count:5},{key:"247",word:"JSX语法中单括号什么时候使用",type:"React",details:"\n    当prop类型不是字符串时\n    在JSX中必须使用花括号{}把值包裹\n    ",latestReview:"2020/12/28",nextReview:"2021/1/27",count:5},{key:"248",word:"JSX语法中style双括号含义",details:"\n    style值有两层花括号\n    外层代表JSX语法 内层代表这是个对象常量\n    ",latestReview:"2021/1/20",nextReview:"2021/1/27",count:3},{key:"249",word:"React super",type:"React",details:"\n    如果组件要定义自己的构造函数\n    构造函数的第一行一定要通过super调用父类React.Components的构造函数\n    ",latestReview:"",nextReview:"",count:6},{key:"250",word:"React组件的数据分为哪两种",type:"React",details:"\n    prop和state\n    无论prop或者state的改变，都可能引发组件的重新渲染\n    prop是组件对外接口，state是组件内部状态\n    ",latestReview:"",nextReview:"",count:6},{key:"251",word:"定义React组件最简单的方式 例",type:"React",details:"\n    定义组件最简单的方式就是编写 JavaScript 函数\n\n    function Welcome(props) {\n      return <h1>Hello, {props.name}</h1>;\n    }\n    该函数是一个有效的 React 组件\n    ",latestReview:"",nextReview:"",count:6},{key:"252",word:"React要求render只能",type:"React",details:"\n    返回一个元素\n    ",latestReview:"2020/12/4",nextReview:"2021/1/3",count:5},{key:"253",word:"React 函数组件",details:"\n    function Welcome(props) {\n      return <h1>Hello, {props.name}</h1>;\n    }\n    因为它接收唯一带有数据的 “props”（代表属性）对象与并返回一个 React 元素\n    这类组件被称为“函数组件”，因为它本质上就是 JavaScript 函数\n    ",latestReview:"2020/12/4",nextReview:"2021/1/3",count:5},{key:"254",word:"React ES6 class组件",type:"React",details:"\n    class Welcome extends React.Component {\n      render() {\n        return <h1>Hello, {this.props.name}</h1>\n      }\n    }\n    ",latestReview:"2020/12/20",nextReview:"2021/1/4",count:4},{key:"255",word:"React元素为DOM标签",type:"React",details:"\n    const element = <div />\n    ",latestReview:"",nextReview:"",count:6},{key:"256",word:"React元素为用户自定义组件",type:"React",details:'\n    const element = <Welcome name="Sara" />\n    ',latestReview:"2020/12/20",nextReview:"2021/1/4",count:4},{key:"257",word:"React中props是什么",type:"React",details:"\n    当React 元素为用户自定义组件时\n    它会将 JSX 所接收的属性（attributes）以及子组件（children）转换为单个对象传递给组件\n    这个对象被称之为 “props”\n    ",latestReview:"2020/12/24",nextReview:"2021/1/23",count:5},{key:"258",word:"最简易的React Hello world",type:"React",details:"\n    ReactDOM.render(\n      <h1>Hello, world!</h1>,\n      document.getElementById('root')\n    )\n\n    它将在页面上展示一个 “Hello, world!” 的标题\n    ",latestReview:"2021/1/20",nextReview:"2021/2/19",count:5},{key:"259",word:"JSX的优点",type:"React",details:"\n    JSX 可以很好地描述 UI 应该呈现出它应有交互的本质形式\n    ",latestReview:"2020/12/20",nextReview:"2021/1/4",count:4},{key:"260",word:"为什么使用JSX 例子",type:"React",details:"\n    JSX 可以很好地描述 UI 应该呈现出它应有交互的本质形式\n    React 认为渲染逻辑本质上与其他 UI 逻辑内在耦合\n\n    如UI中需要绑定处理事件、在某些时刻状态发生变化时需要通知到 UI\n    以及需要在 UI 中展示准备好的数据\n    ",latestReview:"2021/1/21",nextReview:"2021/2/20",count:5},{key:"261",word:"JSX中引号的作用",type:"React",details:'\n    可以通过使用引号 来将属性值指定为字符串字面量\n    const element = <div tabIndex="0"></div>\n    ',latestReview:"",nextReview:"",count:6},{key:"262",word:"JSX中大括号的作用",type:"React",details:"\n    可以使用大括号，来在属性值中插入一个 JavaScript 表达式\n    const element = <img src={user.avatarUrl}></img>\n    ",latestReview:"",nextReview:"",count:10},{key:"263",word:"JSX中大括号与引号混用",type:"React",details:"\n    对于同一属性不能同时使用这两种符号\n    在属性中嵌入 JavaScript 表达式时，不要在大括号外面加上引号\n    应该仅使用引号（对于字符串值）或大括号（对于表达式）中的一个\n    ",latestReview:"",nextReview:"",count:6},{key:"264",word:"JSX等价形式 const element = (..jsx)",type:"React",details:"\n    以下两种示例代码完全等效\n\n    const element = (\n      <h1 className=\"greeting\">\n        Hello, world!\n      </h1>\n    )\n\n    const element = React.createElement(\n      'h1',\n      {className: 'greeting'},\n      'Hello, world!'\n    )\n    ",latestReview:"2021/1/21",nextReview:"2021/1/24",count:1},{key:"265",word:"React.createElement()实际创建的对象",type:"React",details:"\n    const element = {\n      type: 'h1',\n      props: {\n        className: 'greeting',\n        children: 'Hello, world!'\n      }\n    }\n    ",latestReview:"2021/1/20",nextReview:"2021/2/4",count:4},{key:"266",word:"React.createElement()创建的对象被称为",type:"React",details:"\n    React元素\n    ",latestReview:"2020/12/5",nextReview:"2021/1/4",count:5},{key:"267",word:"React元素与浏览器DOM元素的区别",type:"React",details:"\n    与浏览器的 DOM 元素不同，React 元素是创建开销极小的普通对象\n    ",latestReview:"",nextReview:"",count:10},{key:"268",word:"React DOM的作用",type:"React",details:"\n    React DOM 会负责更新 DOM 来与 React 元素保持一致\n    ",latestReview:"",nextReview:"",count:6},{key:"269",word:"如何将React 元素渲染到根 DOM 节点",type:"React",details:"\n    将一个 React 元素渲染到根 DOM 节点中只需把它们一起传入 ReactDOM.render()\n    ReactDOM.render(React元素, 根DOM节点);\n\n    例：\n    const element = <h1>Hello, world</h1>;、\n    ReactDOM.render(element, document.getElementById('root'))\n    ",latestReview:"",nextReview:"",count:10},{key:"270",word:"React元素的特点",type:"React",details:"\n    React 元素是不可变对象\n    一旦被创建，你就无法更改它的子元素或者属性\n    ",latestReview:"",nextReview:"",count:6},{key:"271",word:"React元素 UI理解",type:"React",details:"\n    一个React元素就像电影的单帧：它代表了某个特定时刻的 UI\n    ",latestReview:"",nextReview:"",count:6},{key:"272",word:"React 受控组件",type:"React",details:"\n    该组件不再持有state\n    每次发生变化（如点击）该组件从其父组件中接收值\n    这种状态的组件称作受控组件\n    ",latestReview:"",nextReview:"",count:6},{key:"273",word:"React DOM 基本工作原理",type:"React",details:"\n    React DOM 会将元素和它的子元素与它们之前的状态进行比较\n    并只会进行必要的更新来使 DOM 达到预期的状态\n    ",latestReview:"",nextReview:"",count:6},{key:"274",word:"React什么时候使用函数组件",type:"React",details:"\n    如果你想写的组件只包含一个 render 方法\n    并且不包含 state\n    那么使用函数组件就会更简单\n    ",latestReview:"2020/12/5",nextReview:"2021/1/4",count:5},{key:"275",word:"React组件 基本父子调用",type:"React",details:'\n    function Welcome(props) {\n      return <h1>Hello, {props.name}</h1>;\n    }\n    \n    function App() {\n      return (\n        <div>\n          <Welcome name="Sara" />\n          <Welcome name="Cahal" />\n          <Welcome name="Edite" />\n        </div>\n      );\n    }\n    \n    ReactDOM.render(\n      <App />,\n      document.getElementById(\'root\')\n    )\n    ',latestReview:"2021/1/19",nextReview:"2021/2/18",count:5},{key:"276",word:"flex: 0 0 390px;是什么意思",details:"\n    flex-grow, flex-shrink和flex-basis的简写\n    ",latestReview:"2020/12/24",nextReview:"2021/1/23",count:5},{key:"277",word:"React项目入口文件",type:"React",details:"\n    App.js\n    ",latestReview:"",nextReview:"",count:10},{key:"278",word:"mac下删除某文件夹中所有文件 📖",type:"基础知识",details:"\n    打开命令提示符\n    cd 目标文件夹\n    rm -f *\n    ",latestReview:"2020/12/15",nextReview:"2021/1/14",count:5},{key:"279",word:"windows下删除某文件夹中所有文件 📖",type:"基础知识",details:"\n    打开命令提示符\n    cd 目标文件夹\n    del *\n    ",latestReview:"2020/12/24",nextReview:"2021/1/23",count:5},{key:"280",word:"命令行 mac/windows返回上一级文件夹 📖",type:"基础知识",details:"\n    打开命令提示符\n    cd..\n    ",latestReview:"2021/1/21",nextReview:"2021/1/28",count:3},{key:"281",word:"React在组件中调用 setState 时会发生什么",type:"React",details:"\n    React 都会自动更新其子组件\n    ",latestReview:"",nextReview:"",count:6},{key:"282",word:"在所有含有构造函数的的 React 组件中 构造函数必须",type:"React",details:"\n    构造函数必须以 super(props) 开头\n    ",latestReview:"",nextReview:"",count:10},{key:"283",word:"创建一个长度为9的空数组",type:"javaScript",details:"\n    Array(9).fill(null)\n    ",latestReview:"2020/12/8",nextReview:"2021/1/7",count:10},{key:"284",word:"React中事件命名规范",type:"React",details:"\n    通常会将代表事件的监听 prop 命名为 on[Event] 例：onClick\n    将处理事件的监听方法命名为 handle[Event] 例：handleClick\n    ",latestReview:"",nextReview:"",count:6},{key:"285",word:"什么是模块",type:"javaScript",details:"\n    模块是比对象和函数更大的代码单元\n    ",latestReview:"2020/12/24",nextReview:"2021/1/23",count:5},{key:"286",word:"AMD的设计理念基于",type:"javaScript",details:"\n    AMD的设计理念明确基于浏览器\n    ",latestReview:"2020/12/24",nextReview:"2021/1/23",count:5},{key:"287",word:"CommonJS的设计理念面向",type:"javaScript",details:"\n    CommonJS的设计理念面向通用JavaScript环境（如node.js服务端）\n    不局限于浏览器\n    ",latestReview:"2021/1/20",nextReview:"2021/1/27",count:3},{key:"288",word:"ES6模块语法 定义并导出变量",type:"javaScript",details:'\n    export const xx = "xxx"\n    ',latestReview:"",nextReview:"",count:10},{key:"289",word:"ES6模块语法 导出函数",type:"javaScript",details:"\n    export function xx()\n    ",latestReview:"2020/12/8",nextReview:"2021/1/7",count:5},{key:"290",word:"导出存在的变量",type:"javaScript",details:"\n    const fruit = apple\n    function lemon() {}\n    export {fruit, lemon}\n    ",latestReview:"",nextReview:"",count:10},{key:"291",word:'import xx from "xx"注意点',type:"javaScript",details:"\n    导入默认导出\n    如果要xx.js中不是export default可能会报错\n    ",latestReview:"",nextReview:"",count:10},{key:"292",word:"mac前往文件夹",type:"基础知识",details:"\n    返回桌面\n    shift + command + g\n    ",latestReview:"2020/12/24",nextReview:"2021/1/8",count:4},{key:"293",word:"mac修改host文件 📖",type:"基础知识",details:"\n    shift + command + g 前往文件夹/etc\n    找到hosts文件复制到桌面\n    打开方式-文本编辑\n    编辑成功之后在etc中复制替换\n    ",latestReview:"",nextReview:"",count:6},{key:"294",word:"CSS height:100% 为什么不起作用",type:"CSS",details:"\n    一个元素高度是否可以使用百分比显示，取决于其父级对象\n    #id的父级是body，而浏览器默认状态下，是没有给body一个高度属性的\n    因此当我们直接设置#id为height:100%时，不会产生任何效果\n    ",latestReview:"2020/12/24",nextReview:"2021/1/23",count:5},{key:"295",word:"flex布局最下面一排不满解决办法",type:"CSS",details:"\n    渲染空元素将位置占满并隐藏空元素\n    ",latestReview:"",nextReview:"",count:6},{key:"296",word:"两个div嵌套时内层div设置margin不起作用 原因和解决办法",type:"CSS",details:"\n    原因：\n    当两个容器嵌套时\n    如果外层容器和内层容器之间没有别的元素\n    会把内层元素的margin-top作用于父元素\n    解决方案：\n    ①宽度100% + float浮动 \n    ②父元素padding\n    ③子元素padding\n    ",latestReview:"2020/12/24",nextReview:"2021/1/23",count:5},{key:"297",word:"Vue 如何理解计算属性的function",type:"Vue",details:"\n    计算属性中提供的函数将作为当前Vue实例中该计算属性的getter函数\n    computed: {\n      // 计算属性的 getter\n      reversedMessage: function () {\n        // this 指向 vm 实例\n        return this.message.split('').reverse().join('')\n      }\n    }\n    即 vm.reversedMessage 的 getter 函数\n    ",latestReview:"2020/12/15",nextReview:"2021/1/14",count:5},{key:"298",word:"给第5个以后的所有元素添加样式",type:"CSS",details:"\n    :nth-child(n+6)\n    第n个以后 即第n+1个开始\n    ",latestReview:"",nextReview:"",count:6},{key:"299",word:"什么是鲁棒性",type:"基础知识",details:"\n    鲁棒是Robust的音译，也就是健壮和强壮的意思\n    也是在异常和危险情况下系统生存的能力\n    比如说，计算机软件在输入错误、磁盘故障、网络过载或有意攻击情况下，能否不死机、不崩溃，就是该软件的鲁棒性\n    ",latestReview:"",nextReview:"",count:10},{key:"300",word:"在新窗口打开链接 a标签href注意点",type:"HTML",details:'\n    <a href="http://www.runoob.com/" target="_blank">访问菜鸟教程!</a>\n    注意：地址前面必须加http://  否则打不开\n    ',latestReview:"2020/12/10",nextReview:"2021/1/9",count:5},{key:"301",word:"基本无序列表 📖",type:"HTML",details:"\n    <ul>\n      <li>列表信息1</li>\n      <li>列表信息2</li>\n    </ul>\n    ",latestReview:"",nextReview:"",count:6},{key:"302",word:"基本有序列表 📖",type:"HTML",details:"\n    <ol>\n      <li>列表信息1</li>\n      <li>列表信息2</li>\n    </ol>\n    ",latestReview:"",nextReview:"",count:6},{key:"303",word:"sessionStorage使用 📖",type:"HTML",details:"\n    设置变量：sessionStorage.setItem('变量名', 值)\n    获取变量：sessionStorage.getItem('变量名')\n    清空：sessionStorage.clear()\n    ",latestReview:"",nextReview:"",count:6},{key:"304",word:"localStorage使用 📖",type:"HTML",details:"\n    设置变量：localStorage.setItem('变量名', 值)\n    获取变量：localStorage.getItem('变量名')\n    清空：localStorage.clear()\n    ",latestReview:"",nextReview:"",count:6},{key:"305",word:"require()变量坑",type:"javaScript",details:"\n    require变量会报错\n    Critical dependency: the request of a dependency is an expression\n    若要在require中使用变量应使用 模版字符串 或 固定字符串+拼接变量\n    \n    具体用法进入Vue笔记搜索require\n    ",latestReview:"2020/12/23",nextReview:"2021/1/22",count:5},{key:"306",word:"Vue项目什么时候需要使用require 为什么",type:"javaScript",details:"\n    使用:src时\n    使用require定义之后，将可以动态使用，不用require你就只能写死路径\n    ",latestReview:"2020/12/23",nextReview:"2021/1/22",count:5},{key:"307",word:"VsCode快捷键 删除行",type:"javaScript",details:"\n    command + shift + k\n    ",latestReview:"",nextReview:"",count:6},{key:"308",word:"VsCode转到行",type:"javaScript",details:"\n    control + g\n    ",latestReview:"2020/12/11",nextReview:"2021/1/10",count:10},{key:"309",word:"const作用域",type:"javaScript",details:"\n    let 和 const 都是块级范围\n\n    // const 和 let 只存在于他们定义的块中。\n    {\n      let a = 1;\n      const b = 1;\n    }\n    console.log(a); // ReferenceError\n    console.log(b); // ReferenceError\n    ",latestReview:"",nextReview:"",count:10},{key:"310",word:"{}和[]的valueOf和toString的结果是什么",type:"javaScript",details:'\n    {} 的 valueOf 结果为 {} ，toString 的结果为 "[object Object]"\n    [] 的 valueOf 结果为 [] ，toString 的结果为 ""\n    ',latestReview:"2021/1/21",nextReview:"2021/2/20",count:5},{key:"311",word:"什么是作用域",type:"javaScript",details:"\n    作用域：\n    作用域是定义变量的区域，它有一套访问变量的规则\n    即作用域就是变量与函数的可访问范围，控制着变量与函数的可见性和生命周期\n\n    图像理解：\n    1、脑补一片区域 从天而降定义变量/函数 <- 兑现定义理解\n    2、主体转移：定义的变量/函数 <- 周围的区域是它们的「可访问范围」\n    3、主体转移：周围区域 <- 控制着变量与函数的可见性和生命周期\n    ",latestReview:"2020/12/20",nextReview:"2021/1/4",count:4},{key:"312",word:"作用域链的作用",type:"javaScript",details:"\n    作用域链：\n    作用域链的作用是保证对执行环境有权访问的所有变量和函数的有序访问。\n    通过作用域链，我们可以访问到外层环境的变量和函数。\n    ",latestReview:"2020/12/21",nextReview:"2021/1/5",count:4},{key:"313",word:"作用域链的本质",type:"javaScript",details:"\n    作用域链的本质上是一个指向变量对象的指针列表。\n    变量对象是一个包含了执行环境中所有变量和函数的对象。\n    ",latestReview:"2021/1/21",nextReview:"2021/1/24",count:1},{key:"314",word:"call、apply、bind作用是",type:"javaScript",details:"\n    用来改变函数执行时的this指向\n    ",latestReview:"",nextReview:"",count:6},{key:"315",word:"作用域的作用是",type:"javaScript",details:"\n    这套规则用来管理浏览器引擎\n    如何在「当前作用域」以及「嵌套的作用域」中根据变量（标识符）进行变量查找。\n    ",latestReview:"2020/12/28",nextReview:"2021/1/2",count:2},{key:"316",word:"什么是ajax",type:"javaScript",details:"\n    是一种异步通信的方法，通过直接由 js 脚本向服务器发起 http 通信，\n    然后根据服务器返回的数据，更新网页的相应部分，而不用刷新整个页面的一种方法\n    ",latestReview:"2020/12/28",nextReview:"2021/1/2",count:2},{key:"317",word:"什么是Vuex",type:"Vue",details:"\n    Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式\n    ",latestReview:"2020/12/20",nextReview:"2021/1/19",count:5},{key:"318",word:"Vuex的工作特点",type:"Vue",details:"\n    采用集中式存储管理应用的所有组件的状态\n    并以相应的规则保证状态以一种可预测的方式发生变化\n    ",imgList:["key318-1.jpg"],latestReview:"2020/12/14",nextReview:"2021/1/13",count:5},{key:"319",word:"为什么要用Vuex",type:"Vue",details:"\n    可以解决以下两个问题：\n    多个视图依赖于同一状态\n    来自不同视图的行为需要变更同一状态\n    ",latestReview:"2020/12/20",nextReview:"2021/1/19",count:5},{key:"320",word:"Vuex应用的核心是",type:"Vue",details:"\n    Vuex应用的核心是 store（仓库）\n    store是一个容器 它包含着应用中大部分的状态 (state)\n    ",latestReview:"",nextReview:"",count:6},{key:"321",word:"Vuex和全局对象的不同（两点）",type:"Vue",details:"\n    1、Vuex 的状态存储是响应式的：\n      当 Vue 组件从 store 中读取状态的时候\n      若 store 中的状态发生变化\n      那么相应的组件也会相应地得到高效更新\n    2、不能直接改变 store 中的状态：\n      改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation\n    ",latestReview:"",nextReview:"",count:6},{key:"322",word:"Vuex state是什么",type:"Vue",details:"\n    单一状态树\n    ",latestReview:"2020/12/26",nextReview:"2021/1/25",count:5},{key:"323",word:"如何理解Vuex使用单一状态树？意味着什么？",type:"Vue",details:"\n    用一个对象就包含了全部的应用层级状态\n    这也意味着，每个应用将仅仅包含一个 store 实例\n    ",latestReview:"",nextReview:"",count:6},{key:"324",word:"Vuex Mutation是什么",type:"Vue",details:"\n    用于更改store中的状态\n    更改 Vuex 的 store 中的状态的唯一方法是提交 mutation\n    ",latestReview:"",nextReview:"",count:6},{key:"325",word:"Vuex 如何理解Mutation",type:"Vue",details:"\n    Vuex 中的 mutation 非常类似于事件\n    每个 mutation 都有一个字符串的 事件类型 (type) 和 一个 回调函数 (handler)。\n    这个回调函数就是我们实际进行状态更改的地方，并且它会接受 state 作为第一个参数\n    ",latestReview:"2020/12/31",nextReview:"2021/1/15",count:4},{key:"326",word:"Vuex Action是什么",type:"Vue",details:"\n    Action 类似于 mutation，不同在于：\n\n    1、Action 提交的是 mutation，而不是直接变更状态。\n    2、Action 可以包含任意异步操作\n    ",latestReview:"2020/12/24",nextReview:"2021/1/23",count:5},{key:"327",word:"Vuex Action基本使用方法",type:"Vue",details:"\n    Action 函数接受一个与 store 实例具有相同方法和属性的 context 对象\n\n    可以调用 context.commit 提交一个 mutation\n    或通过 context.state 和 context.getters 来获取 state 和 getters\n    ",latestReview:"2020/12/14",nextReview:"2021/1/13",count:5},{key:"328",word:"重复❗️",type:"Vue",details:"",latestReview:"",nextReview:"",count:0},{key:"329",word:"Vuex Modules是什么",type:"Vue",details:"\n    Vuex 允许我们将 store 分割成模块（module）\n    由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿\n    每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块\n    ",latestReview:"",nextReview:"",count:10},{key:"330",word:"重复❗️",type:"Vue",details:"",latestReview:"",nextReview:"",count:0},{key:"331",word:"Vuex Mutation提交载荷",type:"Vue",details:"\n    可以向 store.commit 传入额外的参数，即 mutation 的 载荷（payload）\n    // ...\n    mutations: {\n      increment (state, n) {\n        state.count += n\n      }\n    }\n    store.commit('increment', 10)\n    ",latestReview:"2020/12/26",nextReview:"2021/1/25",count:5},{key:"332",word:"async是什么",type:"javaScript",details:"\n    「async」作为一个关键字放到函数前面，用于表示函数是一个「异步函数」\n    ",latestReview:"",nextReview:"",count:6},{key:"333",word:"异步函数意味着什么",type:"javaScript",details:"\n    异步函数也就意味着该函数的执行不会阻塞后面代码的执行\n    ",latestReview:"",nextReview:"",count:6},{key:"334",word:"async函数返回什么",type:"javaScript",details:"\n    async函数返回的是一个promise对象\n    ",latestReview:"2020/12/15",nextReview:"2021/1/14",count:5},{key:"335",word:"三种事件模型",type:"javaScript",details:"\n    DOM0级模型\n    IE 事件模型\n    DOM2 级事件模型\n    ",latestReview:"",nextReview:"",count:6},{key:"336",word:"如何获取Promise对象的返回值",type:"javaScript",details:"\n    用then 方法\n    ",latestReview:"",nextReview:"",count:10},{key:"337",word:"await是什么 后面跟什么",type:"javaScript",details:"\n    「await」是「等待」的意思 用于等待一个值\n    它后面可以放任何表达式 一般跟一个返回promise对象的表达式\n    ",latestReview:"2021/1/20",nextReview:"2021/1/27",count:3},{key:"338",word:"如果async函数中有返回一个值 调用时会发生什么",type:"javaScript",details:"\n    当调用该函数时，内部会调用Promise.solve()方法把它转化成一个promise对象作为返回\n    ",latestReview:"2020/12/21",nextReview:"2021/1/5",count:4},{key:"339",word:"如果async函数内部抛出错误 调用时会发生什么",type:"javaScript",details:"\n    那么就会调用Promise.reject()返回一个promise 对象\n    ",latestReview:"2020/12/5",nextReview:"2021/1/4",count:5},{key:"340",word:"Vuex dispatch作用",type:"Vue",details:"\n    提交数据至actions\n    含有异步操作，可用于向后台提交数据\n    ",latestReview:"2020/12/21",nextReview:"2021/1/20",count:5},{key:"341",word:"Vuex dispatch与commit的区别",type:"Vue",details:"\n    commit同步操作\n    dispatch异步操作\n    ",latestReview:"2020/12/21",nextReview:"2021/1/20",count:5},{key:"342",word:"什么是事件",type:"javaScript",details:"\n    事件 是用户操作网页时发生的交互动作或者网页本身的一些操作\n    ",latestReview:"2020/12/21",nextReview:"2021/1/20",count:5},{key:"343",word:"DOM0级模型 使用形式",type:"javaScript",details:"\n    在网页中直接定义监听函数 也可以通过 js属性来指定监听函数\n    ",latestReview:"2020/12/22",nextReview:"2021/1/21",count:5},{key:"344",word:"DOM0级模型 特点",type:"javaScript",details:"\n    没有事件流的概念，不会传播\n    这种方式所有浏览器都兼容\n    ",latestReview:"2020/12/25",nextReview:"2021/1/24",count:5},{key:"345",word:"IE 事件模型 使用形式",type:"javaScript",details:"\n    这种模型通过 attachEvent 来添加监听函数，可以添加多个监听函数，会按顺序依次执行\n    ",latestReview:"2020/12/22",nextReview:"2021/1/21",count:5},{key:"346",word:"IE 事件模型 特点",type:"javaScript",details:"\n    在该事件模型中，一次事件共有两个过程：\n    事件处理阶段，和事件冒泡阶段\n    ",latestReview:"2020/12/31",nextReview:"2021/1/15",count:4},{key:"347",word:"IE 事件模型 过程理解",type:"javaScript",details:"\n    事件处理阶段会首先执行目标元素绑定的监听事件。\n    然后是事件冒泡阶段，冒泡指的是事件从目标元素冒泡到 document\n    依次检查经过的节点是否绑定了事件监听函数，如果有则执行\n    ",latestReview:"2020/12/27",nextReview:"2021/1/1",count:2},{key:"348",word:"DOM2 级事件模型 使用形式",type:"javaScript",details:"\n    事件绑定的函数是 addEventListener，其中第三个参数可以指定事件是否在捕获阶段执行 \n    ",latestReview:"2020/12/21",nextReview:"2021/1/20",count:5},{key:"349",word:"DOM2 级事件模型 特点",type:"javaScript",details:"\n    在该事件模型中，一次事件共有三个过程：\n    事件捕获阶段 事件目标阶段 事件冒泡阶段\n    ",latestReview:"2020/12/21",nextReview:"2021/1/20",count:5},{key:"350",word:"DOM2 Js事件流的三个阶段",type:"javaScript",details:"\n    1.捕获阶段\n    2.目标阶段\n    3.冒泡阶段\n    ",latestReview:"2020/12/22",nextReview:"2021/1/21",count:5},{key:"351",word:"什么是事件捕获",type:"javaScript",details:"\n    当某个元素触发某个事件（如onclick）\n    顶层对象document就会发出一个事件流，随着DOM树的节点向目标元素节点流去，直到到达事件真正发生的目标元素。\n    在这个过程中，事件相应的监听函数是不会被触发的。\n    ",imgList:["key343-1.png"],latestReview:"2020/12/22",nextReview:"2021/1/21",count:5},{key:"352",word:"什么是事件冒泡",type:"javaScript",details:"\n    从目标元素开始，往顶层元素传播。\n    途中如果有节点绑定了相应的事件处理函数，这些函数都会被一次触发。\n    ",imgList:["key343-1.png"],latestReview:"2020/12/22",nextReview:"2021/1/21",count:5},{key:"353",word:"如何理解目标阶段",type:"javaScript",details:"\n    当到达目标元素之后，执行目标元素该事件相应的处理函数。\n    如果没有绑定监听函数，那就不执行。\n    ",latestReview:"2020/12/27",nextReview:"2021/1/1",count:2},{key:"354",word:"什么是事件委托",type:"javaScript",details:"\n    利用浏览器事件冒泡的机制\n    由父节点的监听函数统一处理多个子元素的事件\n    ",latestReview:"2020/12/22",nextReview:"2021/1/21",count:5},{key:"355",word:"事件委托 过程理解",type:"javaScript",details:"\n    因为事件在冒泡过程中会上传到父节点，并且父节点可以通过事件对象获取到目标节点\n    因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件\n    ",latestReview:"2020/12/23",nextReview:"2021/1/22",count:5},{key:"356",word:"事件委托的优点",type:"javaScript",details:"\n    1、减少了内存上的消耗\n      使用事件代理我们可以不必要为每一个子元素都绑定一个监听事件\n    2、实现动态绑定\n      比如新增了一个子节点，我们并不需要单独地为它添加一个监听事件，它所发生的事件会交给父元素中的监听函数来处理\n    ",latestReview:"2020/12/22",nextReview:"2021/1/21",count:5},{key:"357",word:"Promise参数是",type:"javaScript",details:"\n    一个函数 该函数的参数为resolve函数和reject函数\n    ",latestReview:"2020/12/22",nextReview:"2021/1/21",count:5},{key:"358",word:"resolve和reject是什么函数",type:"javaScript",details:"\n    回调函数\n    ",latestReview:"2020/12/22",nextReview:"2021/1/21",count:10},{key:"359",word:"移除数组中的元素（不改变原数组）几种思路",type:"javaScript",details:"\n    1、逆向思维\b：将与移除项不同的项加入一个新数组返回\n    2、利用splice\n    3、利用Array.prototype.filter()\n    ",latestReview:"2020/12/31",nextReview:"2021/1/15",count:4},{key:"360",word:"基本Promise",type:"javaScript",details:"\n    const promise = new Promise(function(resolve, reject) {\n      if (/* 异步操作成功 */) {\n        resolve(data);\n      } else {\n        /* 异步操作失败 */\n        reject(error);\n      }\n    })\n    ",latestReview:"",nextReview:"",count:6},{key:"361",word:"resolve函数的作用",type:"javaScript",details:"\n    在异步操作成功时调用，并将异步操作的「结果」，作为参数传递出去\n    ",latestReview:"2021/1/26",nextReview:"2021/2/25",count:5},{key:"362",word:"reject函数的作用",type:"javaScript",details:"\n    在异步操作失败时调用，并将异步操作报出的「错误」，作为参数传递出去\n    ",latestReview:"2020/12/23",nextReview:"2021/1/22",count:5},{key:"363",word:"Promise如何使用",type:"javaScript",details:"\n    Promise实例生成以后，可以用「then方法」指定resolve状态和reject状态的回调函数\n    ",latestReview:"2020/12/23",nextReview:"2021/1/22",count:10},{key:"364",word:"then方法的参数",type:"javaScript",details:"\n    有两个参数，分别为Promise从pending变为fulfilled和rejected时的回调函数\n    这两个函数都接受Promise对象传出的值作为参数\n    其中第二个参数非必选（即err=>)\n    ",latestReview:"2020/12/27",nextReview:"2021/1/1",count:2},{key:"365",word:"Promise对象三种状态",type:"javaScript",details:"\n    pending：初始值，不是fulfilled，也不是rejected\n    fulfilled：代表操作成功\n    rejected：代表操作失败\n    ",latestReview:"2020/12/23",nextReview:"2021/1/22",count:5},{key:"366",word:"什么是算法",type:"数据结构与算法",details:"\n    算法就是计算或者解决问题的步骤\n    ",latestReview:"",nextReview:"",count:10},{key:"367",word:"时间复杂度O符号的意思是",type:"数据结构与算法",details:"\n    这个符号的意思是“忽略重要项以外的内容”，读音同 Order\n    ",latestReview:"2020/12/28",nextReview:"2021/1/27",count:10},{key:"368",word:"O(n2) 的含义是",type:"数据结构与算法",details:"\n    O(n²) 的含义就是“算法的运行时间最长也就是 n² 的常数倍”\n    ",latestReview:"",nextReview:"",count:6},{key:"369",word:"数据结构决定了数据的什么",type:"数据结构与算法",details:"\n    决定了数据在内存中的的顺序和位置关系\n    ",latestReview:"2020/12/6",nextReview:"2021/1/5",count:5},{key:"370",word:"Array indexOf()方法",type:"javaScript",details:"\n    可返回数组中某个指定的元素位置\n    ",latestReview:"2020/12/21",nextReview:"2021/1/20",count:5},{key:"371",word:"什么是循环链表",type:"数据结构与算法",details:"\n    可以在链表尾部使用指针，并且让它指向链表头部的数据，将链表变成环形。\n    这便是“循环链表”，也叫“环形链表”。\n    ",latestReview:"",nextReview:"",count:6},{key:"372",word:"什么是双向链表",type:"数据结构与算法",details:"\n    一般链表的每个数据都只有一个指针\n    可以把指针设定为两个，并且让它们分别指向前后数据，这就是“双向链表”。\n    ",latestReview:"2020/12/27",nextReview:"2021/1/26",count:5},{key:"373",word:"双向链表的缺点（2个）",type:"数据结构与算法",details:"\n    1、一是指针数的增加会导致存储空间需求增加\n    2、添加和删除数据时需要改变更多指针的指向\n    ",latestReview:"",nextReview:"",count:6},{key:"374",word:"数组在内存中存储的特点",type:"数据结构与算法",details:"\n    数据按顺序存储在内存的连续空间内\n    ",latestReview:"2020/12/18",nextReview:"2021/1/17",count:5},{key:"375",word:"链表对比数组（访问、增删）",type:"数据结构与算法",details:"\n    链表访问慢 增删块\n    数组访问快 增删慢\n    ",latestReview:"2020/12/18",nextReview:"2021/1/17",count:5},{key:"376",word:"数组操作时间复杂度理解",type:"数据结构与算法",details:"\n    假设数组中有 n 个数据\n    访问数据时：\n    由于访问数\n    据时使用的是随机访问（通过下标可计算出内存地址）\n    所以需要的运行时间仅为恒定的O(1)\n    增删数据时：\n    想要向数组中添加新数据时，必须把目标位置后面的数据一个个移开。\n    所以，如果在数组头部添加数据，就需要 O(n) 的时间。删除操作同理\n    ",latestReview:"2020/12/18",nextReview:"2021/1/17",count:5},{key:"377",word:"链表操作时间复杂度理解",type:"数据结构与算法",details:"\n    把链表中的数据量记成n\n    访问数据时：\n    我们需要从链表头部开始查找（线性查找）\n    如果目标数据在链表最后的话，需要的时间就是 O(n)\n    增删数据时：\n    增删数据只需要更改两个指针的指向，所以耗费的时间与 n 无关\n    如果已经到达了添加数据的位置，那么增删操作只需花费 O(1) 的时间\n    ",latestReview:"",nextReview:"",count:6},{key:"378",word:"栈和队列的特点",type:"数据结构与算法",details:"\n    栈：先进后出\n    队列：先进先出\n    ",latestReview:"2020/12/18",nextReview:"2021/1/17",count:5},{key:"379",word:"<base>元素 作用",type:"HTML",details:"\n    作用：描述文档中所有链接的默认链接\n    ",latestReview:"",nextReview:"",count:6},{key:"380",word:"<base>元素 理解",type:"HTML",details:"\n    base制定了一个URL地址 接下来调用的文件或图片等就无须再填写完整的地址\n    只需写上该文件名或图片名即可\n    ",latestReview:"",nextReview:"",count:6},{key:"381",word:"<base>元素 例",type:"HTML",details:'\n    head标签内\n    <base href="http://www.runoob.com/images/" target="_blank">\n    ',latestReview:"2020/12/18",nextReview:"2021/1/17",count:5},{key:"382",word:"<link>元素 作用",type:"HTML",details:"\n    定义了文档与外部资源之间的关系 通常用于连接到样式表\n    ",latestReview:"",nextReview:"",count:6},{key:"383",word:"<link>元素 例",type:"HTML",details:'\n    <link rel="stylesheet" type="text/css" href="mystyle.css">\n    ',latestReview:"2020/12/19",nextReview:"2021/1/18",count:5},{key:"384",word:'rel="stylesheet"意思是',type:"HTML",details:"\n    说明href连接的文档是一个样式表\n    ",latestReview:"2020/12/19",nextReview:"2021/1/18",count:5},{key:"385",word:'type="text/css"意思是',type:"HTML",details:"\n    告诉浏览器这段标签包含的内容是css或text\n    ",latestReview:"2020/12/19",nextReview:"2021/1/18",count:5},{key:"386",word:"src意思是",type:"HTML",details:"\n    src是指source 源属性的值是URL地址\n    ",latestReview:"",nextReview:"",count:6},{key:"387",word:"img alt属性",type:"HTML",details:"\n    指定图像的描述性文本\n    当图像不可见时（下载不成功时），可看到该属性指定的文本\n    ",latestReview:"",nextReview:"",count:6},{key:"388",word:"常用实体引用字符 📖",type:"HTML",details:"\n    <   &lt; \n    >   &gt;\n    \"   &quot;\n    '   &apos; \n    &   &amp;\n    ",latestReview:"2020/12/19",nextReview:"2021/1/18",count:5},{key:"389",word:"<!DOCTYPE html>是什么",type:"HTML",details:"\n    html5标准网页声明\n    ",latestReview:"2020/12/19",nextReview:"2021/1/18",count:10},{key:"390",word:"<head>元素 作用",type:"HTML",details:"\n    是一个容器\n    它包含了所有你想包含在HTML页面中但不想在HTML页面中显示的内容\n    ",latestReview:"",nextReview:"",count:6},{key:"391",word:'<meta charset="utf-8">意思',type:"HTML",details:"\n    这个元素设置文档使用utf-8字符集编码\n    utf-8字符集包含了人类大部分的文字\n    基本上它能识别你放上去的所有文本内容\n    ",latestReview:"",nextReview:"",count:10},{key:"392",word:"如何理解HTML语义化",type:"HTML",details:"\n    让机器可以读懂内容\n    从代码上而不是视觉上来展示页面结构\n    良好的语义化代码可以从代码上就看出来某一块要表达什么\n    ",latestReview:"2020/12/19",nextReview:"2021/1/18",count:5},{key:"393",word:"HTML语义化的优点",type:"HTML",details:"\n    1、有助于架构良好的HTML结构\n    2、有助于搜索引擎建立索引、抓取内容  \n      试想在H1和div中匹配到的关键词哪个会放前面\n    3、有利于团队的开发和维护\n    ",latestReview:"2020/12/29",nextReview:"2021/1/28",count:5},{key:"394",word:"什么是HTML5",type:"HTML",details:"\n    是最新的HTML标准\n    拥有更丰富的语义、图形以及多媒体元素等内容\n    ",latestReview:"",nextReview:"",count:6},{key:"395",word:"HTML5新特性",type:"HTML",details:"\n    1、拖拽释放(Drag and drop) API\n    2、语义化更好的内容标签（header,nav,footer,aside,article,section）\n    3、用于媒介回放的 video 和 audio 元素\n    4、用于绘画的 canvas 元素\n    5、地理(Geolocation) API 用于定位用户的位置\n    6、本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失；\n    7、sessionStorage 的数据在浏览器关闭后自动删除\n    8、表单控件，calendar、date、time、email、url、search\n    9、新的技术webworker、websocket、Geolocation\n    ",latestReview:"2021/1/21",nextReview:"2021/2/20",count:5},{key:"396",word:"<section>标签是什么",type:"HTML",details:"\n    <section>标签就是带有语义的<div>  \n    表示一段专题性的内容，一般带有标题\n    ",latestReview:"",nextReview:"",count:6},{key:"397",word:"sessionStorage作用",type:"HTML",details:"\n    用于本地存储一个会话（session）中的数据\n    ",latestReview:"2020/12/20",nextReview:"2021/1/19",count:5},{key:"398",word:"sessionStorage特点",type:"HTML",details:"\n    这些数据只有在同一个会话中的页面才能访问\n    并且当会话结束后数据也随之销毁\n    因此sessionStorage不是一种持久化的本地存储\n    ",latestReview:"2020/12/20",nextReview:"2021/1/19",count:5},{key:"399",word:"localStorage简介",type:"HTML",details:"\n    持久化的本地存储\n    除非主动删除数据\n    否则数据是永远不会过期\n    ",latestReview:"2020/12/20",nextReview:"2021/1/19",count:5},{key:"400",word:"当两台电脑需要通信时必须要",type:"基础知识",details:"\n    连接它们（有线或无线）（网线或Wifi 蓝牙）\n    ",latestReview:"2020/12/24",nextReview:"2021/1/23",count:10},{key:"401",word:"隐藏元素的方法（4种）",type:"CSS",details:"\n    ①display:none;\n    ②position:absolute;left:-99999px;（足够大）\n    ③visibility:hidden;\n    ④opacity:0;\n    ",latestReview:"2020/12/20",nextReview:"2021/1/19",count:10},{key:"402",word:"vertical-align:center意思是",type:"CSS",details:"\n    把此元素放置在父元素的中部\n    ",latestReview:"2020/12/21",nextReview:"2021/1/20",count:5},{key:"403",word:"vertical-align:center不起作用的原因是",type:"CSS",details:"\n    必须给父元素设置行高\n    ",latestReview:"2020/12/24",nextReview:"2021/1/23",count:5},{key:"404",word:"垂直居中的方法（3种）",type:"CSS",details:"\n    ①子元素vertical-align + 父元素line-height=height\n    ②relative布局top:50% + translateY(-50%)\n    ③父元素flex布局align-items + justify-content  center\n    ",latestReview:"2020/12/24",nextReview:"2021/1/23",count:5},{key:"405",word:"路由器的作用",type:"基础知识",details:"\n    确保从一台电脑上发出的一条信息可以到达正确的电脑\n    ",latestReview:"2020/12/24",nextReview:"2021/1/23",count:5},{key:"406",word:"flex-grow属性",type:"CSS",details:"\n    定义子项宽度之和不足父元素宽度时，子项拉伸的比例，无需直接设置宽度\n    ",latestReview:"2020/12/24",nextReview:"2021/1/23",count:5},{key:"407",word:"路由器工作流程",type:"基础知识",details:"\n    为了把信息发送给电脑B，电脑A必须把信息发送给路由器\n    路由器将收到的信息转发给电脑B，并且确保信息不会发送给电脑C\n    ",latestReview:"2020/12/24",nextReview:"2021/1/23",count:10},{key:"408",word:"flex-shrink属性",type:"CSS",details:"\n    定义项目的缩小比例，默认为1，即如果空间不足，该项目将缩小\n    ",latestReview:"2020/12/24",nextReview:"2021/1/23",count:5},{key:"409",word:"flex-basis属性",type:"CSS",details:"\n    属性定义了在分配多余空间之前，项目占据的主轴空间\n    它的默认值为auto\n    ",latestReview:"2020/12/24",nextReview:"2021/1/23",count:5},{key:"410",word:"栅格系统特点",type:"CSS",details:"\n    会有自动的padding样式（为了创建列colum之间的间隔）\n    有全局的font-size\n    box-sizing初始为border-box\n    ",latestReview:"2020/12/24",nextReview:"2021/1/23",count:5},{key:"411",word:"选择某类下所有子元素 📖",type:"CSS",details:"\n    > * {\n      ...\n    } \n    ",latestReview:"2020/12/24",nextReview:"2021/1/23",count:5},{key:"412",word:"将对象转化为url形式 📖",type:"工作经验",details:"\n    需要Qs模块\n    cnpm install qs\n    import Qs from 'qs'\n    data对象 = Qs.stringify(data对象)\n    ",latestReview:"2020/12/24",nextReview:"2021/1/23",count:5},{key:"413",word:'component: () => import("../components/pages/login")箭头函数等价于',type:"javaScript",details:"\n    component: function () {\n      return import('../components/pages/login')\n    }\n    ",latestReview:"2020/12/24",nextReview:"2021/1/23",count:10},{key:"414",word:"根据布尔值动态更换选择器",type:"Vue",details:'\n    :class="{样式类1:布尔值1,样式类2:布尔值2}"\n    ',latestReview:"2020/12/25",nextReview:"2021/1/24",count:5},{key:"415",word:"当一个函数创建后其作用域链会如何",type:"javaScript",details:"\n    当一个函数创建后\n    它的作用域链会被创建此函数的作用域中可访问的数据对象填充\n\n    例：函数add创建时，它的作用域链中会填入一个全局对象\n    该全局对象包含了所有全局变量，如下图所示\n    （注意：图片只例举了全部变量中的一部分）\n    ",imgList:["key415-1.jpg"],latestReview:"2021/1/19",nextReview:"2021/2/18",count:5},{key:"416",word:"vue动态控制链接跳转（有地址跳转没有则停止）📖",type:"Vue",details:"\n    <a :href=\"条件 ? ‘http://¥{变量地址}‘ : 'javascript:void(0)'\"></a>\n    ",latestReview:"",nextReview:"",count:6},{key:"417",word:"面试官认可的几种编码习惯",type:"工作经验",details:"\n    1、思考清楚再编码 不要一听到题目就匆忙打开编程软件\n    2、良好的代码命名和缩进对齐习惯\n    3、能够单元测试\n    ",latestReview:"",nextReview:"",count:6},{key:"418",word:"参加面试前 应聘者应做好以下准备",type:"工作经验",details:"\n    1、规划好路线并估算出行时间\n    2、准备得体的衣服\n    3、注意面试邀请函里的面试流程\n    4、准备几个要问的问题以应对面试后的提问环节\n    ",latestReview:"2021/1/26",nextReview:"2021/2/25",count:10},{key:"419",word:"描述项目的STAR模型",type:"工作经验",details:"\n    Situation 简短的项目背景\n    Task 完成的任务\n    Action 为了完成任务做了哪些工作 怎么做的\n    Result 自己的贡献\n    ",latestReview:"2020/12/25",nextReview:"2021/1/24",count:5},{key:"420",word:"javaScript中作用域分为哪两种",type:"工作经验",details:"\n    全局作用域（Global Scope）\n    局部作用域（Local Scope）\n    ",latestReview:"2020/12/20",nextReview:"2021/1/4",count:4},{key:"421",word:"在描述项目的STAR模型中 Task部分要注意的是",type:"工作经验",details:"\n    介绍任务时要注意区分“参与”和“负责”\n    如果“负责”了某个项目则很可能会问项目的总体框架设计、核心算法、团队合作等问题\n    ",latestReview:"2020/12/25",nextReview:"2021/1/24",count:10},{key:"422",word:"在描述项目的STAR模型中 Result部分最好使用什么说明",type:"工作经验",details:"\n    介绍自己贡献时可以写具体些\n    最好能用数字加以说明\n    ",latestReview:"2020/12/25",nextReview:"2021/1/24",count:5},{key:"423",word:"拥有全局作用域的对象有什么特点",type:"工作经验",details:"\n    在代码中任何地方都可以访问到\n    ",latestReview:"2021/1/20",nextReview:"2021/2/19",count:5},{key:"424",word:"在介绍项目经验时主次是什么",type:"工作经验",details:"\n    无论是简历介绍或口头介绍\n    应聘者不必详细描述项目的背景\n    而要突出介绍完成自己的工作以及取得的成绩\n    ",latestReview:"2020/12/25",nextReview:"2021/1/24",count:5},{key:"425",word:"简历中何谓“了解”",type:"工作经验",details:"\n    “了解”指对某一个技术只是上过课或看过书\n    但没有做过实际项目\n    ",latestReview:"2020/12/25",nextReview:"2021/1/24",count:5},{key:"426",word:"是否需要在简历中使用“了解”",type:"工作经验",details:"\n    通常不建议在简历中列出只是肤浅地了解一点的技能\n    除非这项技术应聘的职位确实需要\n    ",latestReview:"2020/12/25",nextReview:"2021/1/24",count:5},{key:"427",word:"简历中描述技能的掌握程度大部分应该是",type:"工作经验",details:"\n    简历中描述技能的掌握程度大部分应该是 熟悉\n    ",latestReview:"2020/12/25",nextReview:"2021/1/24",count:10},{key:"428",word:"简历中何谓“熟悉”",type:"工作经验",details:"\n    在实际项目中使用某一项技术已经有较长的时间\n    通过查阅相关的文档可以独立解决大部分问题\n    可称之为熟悉\n    ",latestReview:"2020/12/25",nextReview:"2021/1/24",count:5},{key:"429",word:"简历中何谓“精通”",type:"工作经验",details:"\n    对一项技术得心应手\n    在开发过程中同事请教该领域问题都有信心且有能力解决\n\n    不要轻易使用“精通”\n    除非能够很轻松回答这个领域里绝大多数问题\n    ",latestReview:"2020/12/25",nextReview:"2021/1/24",count:5},{key:"430",word:"面试官问“为什么跳槽”的目的",type:"工作经验",details:"\n    面试官不会期待一个标准答案\n    只是想通过这个问题来了解应聘者的性格\n    ",latestReview:"2020/12/25",nextReview:"2021/1/24",count:5},{key:"431",word:"回答”为什么跳槽“时的注意点 需要避免的四个原因",type:"工作经验",details:"\n    不要流露出负面情绪\n\n    1、老板太苛刻\n    2、同事太难相处\n    3、加班太频繁\n    4、工资太低\n    ",latestReview:"2020/12/25",nextReview:"2021/1/24",count:5},{key:"432",word:"技术面谈到薪资问题时的巧妙回答",type:"工作经验",details:"\n    我会努力工作\n    工资公司看着给\n    相信贵司不会亏待勤奋的员工\n\n    等通过技术面掌握主动\n    工资问题在技术面之后与HR谈\n    ",latestReview:"2020/12/25",nextReview:"2021/1/24",count:10},{key:"433",word:"回答“为什么跳槽”的一个可参考答案",type:"工作经验",details:"\n    目前的工作做了一段时间\n    已经没有太多收获和激情了\n    因此希望寻找一份更有挑战的工作\n    ",latestReview:"2020/12/25",nextReview:"2021/1/24",count:5},{key:"434",word:"面试官关注的应聘者的5种素质",type:"工作经验",details:"\n    1、扎实的基础知识\n    2、能写高质量的代码\n    3、分析问题时思路清晰\n    4、能优化时间效率和空间效率\n    5、学习沟通等各方面能力\n    ",latestReview:"2020/12/26",nextReview:"2021/1/25",count:5},{key:"435",word:"面试遇到简单问题一定要注意",type:"工作经验",details:"\n    一定要注重细节\n    越简单的问题 面试官期望着就越高\n    除了完成基本功能之外 还要考虑到边界条件、错误处理等各个方面\n    ",latestReview:"2020/12/26",nextReview:"2021/1/25",count:5},{key:"436",word:"面试遇到复杂问题应该怎么做",type:"工作经验",details:"\n    可通过画图、举具体例子分析和分解复杂问题等方法\n    先清理思路再动手编程\n    此外还应该不断优化时间和空间效率\n    力求找到最优解法\n    ",latestReview:"2020/12/26",nextReview:"2021/1/25",count:5},{key:"437",word:"面试中如何表现自己的沟通能力",type:"工作经验",details:"\n    适当主动提问 以弄清楚题目的要求\n    ",latestReview:"2020/12/26",nextReview:"2021/1/25",count:5},{key:"438",word:"面试中如何表现自己的学习能力",type:"工作经验",details:"\n    面试官问的前后两个问题相关时\n    尽量把解决前面问题的思路迁移到后面问题去\n    ",latestReview:"2020/12/26",nextReview:"2021/1/25",count:10},{key:"439",word:"编程基本功体现在哪三个方面",type:"工作经验",details:"\n    编程语言\n    数据结构\n    算法\n    ",latestReview:"2020/12/26",nextReview:"2021/1/25",count:5},{key:"440",word:"面试官如何考察应聘者是否注重代码质量",type:"工作经验",details:"\n    面试官会格外关注边界条件、特殊输入等看似细枝末节但实至关重要但地方\n    ",latestReview:"2020/12/26",nextReview:"2021/1/25",count:5},{key:"441",word:"遇到简单问题却被拒应该",type:"工作经验",details:"\n    认真反思思路或代码中存在哪些漏洞\n    ",latestReview:"",nextReview:"",count:6},{key:"442",word:"应该想到的几个边界条件和特殊值",type:"工作经验",details:"\n    输入的字符串中有非数字字符和正负号\n    最大整数和最小负整数的溢出\n    输入的字符串不能转换成整数时 应如何处理\n    ",latestReview:"2020/12/26",nextReview:"2021/1/25",count:5},{key:"443",word:"数组求和的思路（5种）",type:"工作经验",details:"\n    1、常规for循环\n    2、递归\n    3、forEach遍历\n    4、eval\n    5、函数式编程\n    ",latestReview:"",nextReview:"",count:6},{key:"444",word:"let arr = [1, 2, 3, 4, 5] slice(1) = ?",type:"javaScript",details:"\n    [2, 3, 4, 5]\n    slice第一个参数为start 规定从何处结束选取\n    ",latestReview:"2020/12/26",nextReview:"2021/1/25",count:5},{key:"445",word:"数组求和 递归写法",type:"javaScript",details:"\n    function sum(arr) {\n      if (!arr.length) {\n        return 0\n      } else if (arr.length === 1) {\n        return arr[0]\n      } else return arr[0] + sum(arr.slice(1))\n    }\n    ",latestReview:"2020/12/26",nextReview:"2021/1/25",count:10},{key:"446",word:"!arr.length等价于",type:"javaScript",details:"\n    arr.length === 0\n    数组为空\n    ",latestReview:"2020/12/26",nextReview:"2021/1/25",count:5},{key:"447",word:"构建互联网思路",type:"基础知识",details:"\n    两电脑互传→多电脑引入路由器→\n    多路由器通过电话线和猫将信息送到ISP（互联网服务商）→多个ISP互联组成互联网\n    ",latestReview:"2020/12/26",nextReview:"2021/1/25",count:5},{key:"448",word:"IP地址的理解 也叫",type:"基础知识",details:"\n    连接到网络中的电脑的唯一的地址标记 也叫域名\n    ",latestReview:"2020/12/26",nextReview:"2021/1/25",count:5},{key:"449",word:"网络连接的作用",type:"基础知识",details:"\n    允许你在互联网上发送和接受数据\n    ",latestReview:"2020/12/26",nextReview:"2021/1/25",count:5},{key:"450",word:"TCP是什么",type:"基础知识",details:"\n    传输控制协议\n    ",latestReview:"2020/12/26",nextReview:"2021/1/25",count:5},{key:"451",word:"IP是什么",type:"基础知识",details:"\n    因特网互联协议\n    ",latestReview:"2021/1/26",nextReview:"2021/1/27",count:0},{key:"452",word:"TCP/IP协议的作用",type:"基础知识",details:"\n    定义数据如何传输的通信协议\n    ",latestReview:"2020/12/26",nextReview:"2021/1/25",count:5},{key:"453",word:"DNS作用",type:"基础知识",details:"\n    将域名翻译为IP地址\n    ",latestReview:"2020/12/26",nextReview:"2021/1/25",count:5},{key:"454",word:"DNS协议默认端口号",type:"基础知识",details:"\n    53\n    ",latestReview:"",nextReview:"",count:0},{key:"455",word:"DNS协议大多运行在什么协议之上",type:"基础知识",details:"\n    UDP协议\n    ",latestReview:"",nextReview:"",count:6},{key:"456",word:"如何理解DNS",type:"基础知识",details:"\n    可理解为网站通讯录\n    ",latestReview:"",nextReview:"",count:0},{key:"457",word:"浏览器如何使用DNS",type:"基础知识",details:"\n    在浏览器内输入一个网址时\n    浏览器获取网页之前将会查看域名系统浏览器需要找到存放你想要的网页的服务器\n    才能发送 HTTP 请求到正确的地方\n    ",latestReview:"",nextReview:"",count:0},{key:"458",word:"写页面首先要做的事情是",type:"工作经验",details:"\n    首先确定页面大布局（一列 二列 ?）\n    搭好框架后缩放调试\n    ",latestReview:"",nextReview:"",count:6},{key:"459",word:"能否使用边距解决对齐问题",type:"工作经验",details:"\n    不能 因为在开发电脑上显示对齐不代表\n    在其它不同分辨率的屏幕上px值相同\n    ",latestReview:"",nextReview:"",count:10},{key:"460",word:"能否使用边距解决对齐问题",type:"工作经验",details:"\n    不能 因为在开发电脑上显示对齐不代表\n    在其它不同分辨率的屏幕上px值相同\n    ",latestReview:"2021/1/19",nextReview:"2021/1/20",count:0},{key:"461",word:"模块化的作用",type:"javaScript",details:"\n    使用模块可以将程序进行归类\n    ",latestReview:"2020/12/28",nextReview:"2021/1/27",count:5},{key:"462",word:"手写原生ajax",type:"javaScript",details:"\n    手写原生ajax\n    //1：创建Ajax对象\n    var xhr = window.XMLHttpRequest ? new XMLHttpRequest() : new ActiveXObject('Microsoft.XMLHTTP');  // 兼容IE6及以下版本\n    //2：配置 Ajax请求地址\n    xhr.open('get','index.xml',true);\n    //3：发送请求\n    xhr.send(null); // 严谨写法\n    //4:监听请求，接受响应\n    xhr.onreadysatechange=function() {\n      if(xhr.readySate === 4 && xhr.status === 200 || xhr.status === 304) {\n        console.log(xhr.responsetXML)\n      }\n    }\n    ",latestReview:"",nextReview:"",count:0},{key:"463",word:":nth-child(n)意思是",type:"CSS",details:"\n    所有元素\n    ",latestReview:"",nextReview:"",count:10},{key:"464",word:"数组的length属性可以做什么",type:"CSS",details:"\n    从数组末尾移除项或添加新项\n    ",latestReview:"",nextReview:"",count:0},{key:"465",word:"数组最后一项 length巧妙表达",type:"javaScript",details:"\n    array[array.length]\n    ",latestReview:"",nextReview:"",count:10},{key:"466",word:"前端框架的作用",type:"工作经验",details:"\n    框架可以让你从重复低级工作中脱离出来\n    特别是应用复杂到一定程度时\n    如果没有框架层的抽象\n    代码往往会复杂得难以维护\n    在前端开发越来越复杂的今天 框架已经是必不可少的了\n    ",latestReview:"",nextReview:"",count:0},{key:"467",word:"一个优秀的前端开发工程师 一定要",type:"工作经验",details:"\n    对产品有爱 如果做的产品自己都不用\n    那么很多交互细节可能会缺乏深思 在潜意识里忽略掉\n    如果自己也用这个产品 那么你就不仅仅是在编码\n    同时还是PD、PM、测试等等角色 \n    甚至你就是这个产品的CEO\n    ",latestReview:"",nextReview:"",count:10},{key:"468",word:"小公司对应用运行效率等指标",type:"工作经验",details:"\n    并不是太关心\n    ",latestReview:"",nextReview:"",count:0},{key:"469",word:"浏览器的主要功能",type:"基础知识",details:"\n    向服务器发出请求\n    在浏览器窗口中展示您想要访问的网络资源\n    ",latestReview:"",nextReview:"",count:0},{key:"470",word:"浏览器的主要组件（7部分）",type:"基础知识",details:"\n    1、用户界面\n    2、浏览器引擎\n    3、渲染引擎\n    4、网络\n    5、用户界面后端\n    6、javaScript解释器\n    7、数据存储\n    ",latestReview:"2021/1/20",nextReview:"2021/1/21",count:10},{key:"471",word:"❗️重复",type:"基础知识",details:"\n    1、用户界面\n    2、浏览器引擎\n    3、渲染引擎\n    4、网络\n    5、用户界面后端\n    6、javaScript解释器\n    7、数据存储\n    ",latestReview:"",nextReview:"",count:0},{key:"472",word:"浏览器引擎的作用",type:"基础知识",details:"\n    在用户界面按和渲染引擎之间传送指令\n    ",latestReview:"2021/1/20",nextReview:"2021/1/21",count:0},{key:"473",word:"渲染引擎的作用是",type:"基础知识",details:"\n    负责显示请求的内容\n    ",latestReview:"",nextReview:"",count:0},{key:"474",word:"浏览器 网络部分的作用是",type:"基础知识",details:"\n    用于网络调用 如HTTP请求\n    ",latestReview:"",nextReview:"",count:0},{key:"475",word:"Vue SPA页面理解",type:"Vue",details:"\n    整个项目只加载了一个index.html文件\n    ",latestReview:"",nextReview:"",count:0},{key:"476",word:'指令"git add ."的意思是',type:"工作经验",details:"\n    将当前目录下所有文件都添加进来\n    ",latestReview:"",nextReview:"",count:0},{key:"477",word:"Vue cli-3.0根html放置在",type:"Vue",details:"\n    public文件夹下\n    ",latestReview:"",nextReview:"",count:0},{key:"478",word:"Vue main.js文件是什么",type:"Vue",details:"\n    入口文件\n    ",latestReview:"",nextReview:"",count:0},{key:"479",word:"App.vue是什么 作用是",type:"Vue",details:"\n    主组件 所有组件都是在App.vue下进行切换\n    ",latestReview:"2021/1/19",nextReview:"2021/1/20",count:0},{key:"480",word:"import xx form ‘一个文件夹’ 打包的时候会",type:"Vue",details:"\n    自动查找文件夹里面的index.js文件\n    ",latestReview:"2021/1/20",nextReview:"2021/1/21",count:0},{key:"481",word:"Vue项目的渲染逻辑",type:"Vue",details:'\n    index.html中id="app"的div被挂载到 ->\n    main.js中的vue实例中 ->\n    main.js中引入主组件App.vue ->\n    App.vue中布置好<router-view>标签 ->\n    <router-view>标签渲染任意写好的组件\n    ',latestReview:"",nextReview:"",count:0},{key:"482",word:"Vue redirect的作用（2个）",type:"Vue",details:"\n    ①加载同一个组件 显示不同路径\n    ②加载main+1个组件（导航+具体内容）\n\n    在一个公共部分组件中添加<router-view>标签后\n    可以定义加载其它不同的组件（使用children）\n    即需要加载某个组件的同时需要显示别的路径和加载别的组件\n    ",latestReview:"2021/1/19",nextReview:"2021/1/20",count:0},{key:"483",word:"js报错 Cannot read property ‘amount‘ of null 原因",type:"javaScript",details:"\n    JS运行的时候页面还没有加载完成\n    JS代码找不到页面元素 就会抛出这个问题\n    ",latestReview:"2021/1/20",nextReview:"2021/1/21",count:0},{key:"484",word:"Vue redirect实现导航思路",type:"Vue",details:"\n    1、修改默认路径为需默认显示组件路径（导航index）\n    2、修改默认显示组件加载组件为该组件（不能是子组件）\n    3、使用children配置子路由组件\n    4、在需显示组件路径路由中配置redirect\n      重定向至需显示组件的路由\n    ",latestReview:"",nextReview:"",count:0},{key:"485",word:"Vue redirect实现导航思路",type:"Vue",details:"\n    1、修改默认路径为需默认显示组件路径（导航index）\n    2、修改默认显示组件加载组件为该组件（不能是子组件）\n    3、使用children配置子路由组件\n    4、在需显示组件路径路由中配置redirect\n      重定向至需显示组件的路由\n    ",latestReview:"2021/1/19",nextReview:"2021/1/20",count:0},{key:"486",word:"如何删除字符串中最后一项",type:"javaScript",details:"\n    substr(0, str.length - 1)\n    ",latestReview:"2021/1/20",nextReview:"2021/1/23",count:10},{key:"487",word:"substr方法",type:"javaScript",details:"\n    截取字符串指定下标范围内的字符\n    ",latestReview:"2021/1/19",nextReview:"2021/1/20",count:0},{key:"488",word:"substr方法",type:"javaScript",details:"\n    截取字符串指定下标范围内的字符\n    ",latestReview:"",nextReview:"",count:10},{key:"489",word:"变量命名规范",type:"工作经验",details:'\n    类型+对象描述\n    推荐  const tableTitle="LoginTable";\n    不推荐 const getTitle = "LoginTable"\n    ',latestReview:"",nextReview:"",count:0},{key:"490",word:"标志性变量需固定前缀含义（4个）",type:"工作经验",details:"\n    show→DOM节点显示隐藏\n    is→表示“是不是”含义的\n    has→表示“有没有”含义的\n    able→表示“能不能”含义的\n    ",latestReview:"",nextReview:"",count:0},{key:"491",word:"组件命名规范",type:"工作经验",details:"\n    大驼峰式命名方法\n    如FormModule\n    ",latestReview:"",nextReview:"",count:10},{key:"492",word:"CSS class命名规范",type:"工作经验",details:"\n    字母组成 中划线拼接\n    例：.header-title\n    ",latestReview:"",nextReview:"",count:10},{key:"493",word:"常量 命名方法 命名规范",type:"工作经验",details:"\n    命名方法：全部大写\n    命名规范：\n    使用大写字母和下划线来组合命名\n    下划线用以分割单词\n    ",latestReview:"2021/1/19",nextReview:"2021/1/20",count:0},{key:"494",word:"函数 命名方法 命名规范",type:"工作经验",details:"\n    命名方法：小驼峰方式 ( 构造函数使用大驼峰命名法 )\n    命名规范：前缀为动词\n    ",latestReview:"2021/1/20",nextReview:"2021/1/21",count:0},{key:"495",word:"图片命名方式",type:"工作经验",details:"\n    如果可以分类 用前缀代表分类 下划线间隔\n    例：广告banner，标志logo，菜单menu等分类\n    banner_souhu.png\n    banner_sina.png\n    ",latestReview:"2021/1/20",nextReview:"2021/1/21",count:0},{key:"496",word:"Vue 什么是响应式",type:"Vue",details:"DOM和数据建立关联",latestReview:"",nextReview:"",count:0},{key:"497",word:"Vue双向绑定原理",type:"Vue",details:"\n    采用数据劫持结合发布者-订阅者模式\n    通过Object.defineProperty()\n    来劫持各个属性的setter，getter \n    数据变动时发布消息给订阅者\n    触发相应的监听回调\n    ",latestReview:"",nextReview:"",count:0},{key:"498",word:"数据劫持的触发原理是",type:"Vue",details:"\n    属性在赋值的时候触发set方法\n    ",latestReview:"",nextReview:"",count:0},{key:"499",word:"遇到难解问题时的工作原则",type:"工作经验",details:"\n    先解决其它所有简单的 不要死磕\n    ",latestReview:"",nextReview:"",count:10},{key:"500",word:"什么是弱口令",type:"工作经验",details:"\n    通常认为是\n    容易被别人猜测到或被破解工具破解的口令\n    ",latestReview:"",nextReview:"",count:0},{key:"501",word:"createElement()方法作用",type:"HTML",details:"\n    通过指定名称创建一个元素\n    例：创建一个style元素\n    let style = document.createElement('style')\n    ",latestReview:"",nextReview:"",count:0},{key:"502",word:"setAttribute() 方法作用",type:"HTML",details:"\n    设置元素的指定属性\n    例：\n    style.setAttribute('type', 'text/css')\n    ",latestReview:"2021/1/19",nextReview:"2021/1/20",count:0},{key:"503",word:"Vue项目使用定时器 注意点",type:"Vue",details:"\n    Vue组件生命周期结束后定时器不会跟着销毁\n    需要在destroyed()生命周期内清除定时器\n    ",latestReview:"",nextReview:"",count:0},{key:"504",word:"拥有全局作用域的三种情形",type:"javaScript",details:"\n    1、「最外层函数」和在「最外层函数外面」定义的变量\n    2、所有末定义直接赋值的变量自动声明为拥有全局作用域\n    3、所有window对象的属性拥有全局作用域\n    ",latestReview:"2020/12/20",nextReview:"2021/1/4",count:4},{key:"505",word:"插件文件头部注释",type:"工作经验",details:"\n    ctrl + command + i\n    ",latestReview:"",nextReview:"",count:10},{key:"506",word:"插件函数注释",type:"工作经验",details:"\n    ctrl + command + t\n    ",latestReview:"",nextReview:"",count:0},{key:"507",word:"Promise.all作用",type:"javaScript",details:"\n    Promise.all可以将多个Promise实例包装成一个新的Promise实例\n    同时，成功和失败的返回值是不同的:\n    成功的时候返回的是一个结果数组\n    而失败的时候则返回最先被reject失败状态的值\n    ",latestReview:"2020/12/26",nextReview:"2021/1/10",count:4},{key:"508",word:"Promise.all获得结果的顺序与什么相同",type:"javaScript",details:"\n    Promise.all获得的成功结果的数组里面的数据顺序和Promise.all接收到的数组顺序是一致的\n    即p1的结果在前，即便p1的结果获取的比p2要晚\n    ",latestReview:"2020/12/26",nextReview:"2021/1/10",count:4},{key:"509",word:"Promise.all应用场景",type:"javaScript",details:"\n    1、Promse.all在处理多个异步处理时非常有用\n    比如说一个页面上需要等两个或多个ajax的数据回来以后才正常显示\n    在此之前只显示loading图标\n    2、可以解决发送多个请求并根据请求顺序获取和使用数据的场景\n    ",latestReview:"2021/1/21",nextReview:"2021/2/20",count:5},{key:"510",word:"Promise.race作用",type:"javaScript",details:"\n    顾名思义，Promse.race就是赛跑的意思，意思就是说\n    Promise.race([p1, p2, p3])里面哪个结果获得的快，就返回那个结果\n    不管结果本身是成功状态还是失败状态\n    ",latestReview:"2021/1/20",nextReview:"2021/2/19",count:10},{key:"511",word:"Promise.race应用场景",type:"javaScript",details:"\n    race的使用场景：\n    多台服务器部署了同样的服务端代码\n    假如我要获取一个商品列表接口\n    我可以在 race 中写上所有服务器中的查询商品列表的接口地址\n    哪个服务器响应快，就从哪个服务器拿数据\n    ",latestReview:"2020/12/26",nextReview:"2021/1/10",count:4},{key:"512",word:"Promise的缺点",type:"javaScript",details:"\n    1、无法取消Promise 一旦新建就会立即执行，无法中途取消\n    2、如果不设置回调函数，Promise内部抛出的错误，不会反应到外部\n    3、当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）\n    ",latestReview:"2021/1/20",nextReview:"2021/2/19",count:5},{key:"513",word:"什么是暂时性死区",type:"javaScript",details:"\n    只要块级作用域内存在let命令\n    它所声明的变量就“绑定”（binding）这个区域\n    不再受外部的影响\n    ES6 明确规定，如果区块中存在let和const命令\n    这个区块对这些命令声明的变量，从一开始就形成了封闭作用域\n    凡是在声明之前就使用这些变量，就会报错\n    ",latestReview:"2021/1/26",nextReview:"2021/2/25",count:5},{key:"514",word:"暂时性死区 例",type:"javaScript",details:"\n    var tmp = 123;\n\n    if (true) {\n      tmp = 'abc'; // ReferenceError\n      let tmp;\n    }\n    上面代码中，存在全局变量tmp\n    但是块级作用域内let又声明了一个局部变量tmp\n    导致后者绑定这个块级作用域\n    所以在let声明变量前，对tmp赋值会报错\n    ",latestReview:"2021/1/21",nextReview:"2021/1/26",count:2},{key:"515",word:"浏览器内核分为哪两部分",type:"基础知识",details:"\n    渲染引擎 JS引擎\n    ",latestReview:"2021/1/20",nextReview:"2021/2/19",count:5},{key:"516",word:"四大浏览器内核",type:"基础知识",details:"\n    Trident内核（IE内核）\n    Gecko内核（火狐）\n    Presto内核（Opera）\n    Webkit（Safari、Chrome）\n    ",latestReview:"2021/1/20",nextReview:"2021/2/19",count:5},{key:"517",word:"--save和--save-dev的区别",type:"webpack",details:"\n    --save是生产环境的依赖，也就是供给用户使用的依赖\n    --save-dev是开发环境的依赖，比如Webpack\n    在代码完成并且打包之后，就不需要再使用到它了\n    显然用户是无需接触到Webpack的，所以这里Webpack属于开发环境的依赖\n    ",latestReview:"2020/12/27",nextReview:"2021/1/11",count:10},{key:"518",word:"webpack四个核心概念",type:"webpack",details:"\n    入口(entry)\n    输出(output)\n    loader\n    插件(plugins)\n    ",latestReview:"2021/1/26",nextReview:"2021/2/25",count:5},{key:"519",word:"webpack 入口(entry)的作用",type:"webpack",details:"\n    指示 webpack 应该使用哪个模块，来作为构建其内部依赖图的开始\n    进入入口起点后，webpack 会找出有哪些模块和库是入口起点（直接和间接）依赖的\n    每个依赖项随即被处理，最后输出到称之为 bundles 的文件中\n\n    可以通过在 webpack 配置中配置 entry 属性，来指定一个入口起点（或多个入口起点）\n    ",latestReview:"2021/1/20",nextReview:"2021/2/19",count:5},{key:"520",word:"webpack 出口(output)的作用",type:"webpack",details:"\n    output 属性告诉 webpack 在哪里输出它所创建的 bundles\n    以及如何命名这些文件\n    ",latestReview:"",nextReview:"",count:6},{key:"521",word:"webpack 入口出口默认值为",type:"webpack",details:"\n    入口为 ./src\n    出口为 ./dist\n    ",latestReview:"",nextReview:"",count:6},{key:"522",word:"configureWebpack",type:"webpack",details:"\n    如果这个值是一个对象，则会通过 webpack-merge 合并到最终的配置中\n\n    如果这个值是一个函数，则会接收被解析的配置作为参数。\n    该函数及可以修改配置并不返回任何东西，也可以返回一个被克隆或合并过的配置版本。\n    ",latestReview:"2021/1/20",nextReview:"2021/2/19",count:5},{key:"523",word:"什么是 格式化上下文",type:"CSS",details:"\n    它是页面中的一块渲染区域，并且有一套渲染规则\n    它决定了其子元素将如何定位，以及和其他元素的关系和相互作用\n    ",latestReview:"2021/1/26",nextReview:"2021/1/27",count:10},{key:"524",word:"什么是BFC",type:"CSS",details:"\n    Block formatting context\n    块级格式化上下文\n    ",latestReview:"2021/1/21",nextReview:"2021/2/20",count:10},{key:"525",word:"如何理解BFC",type:"CSS",details:"\n    具有 BFC 特性的元素可以看作是隔离了的独立容器\n    器里面的元素不会在布局上影响到外面的元素\n    并且 BFC 具有普通容器所没有的一些特性\n\n    通俗一点来讲\n    可以把 BFC 理解为一个封闭的大箱子\n    箱子内部的元素无论如何翻江倒海，都不会影响到外部\n    ",latestReview:"2020/12/31",nextReview:"2021/1/15",count:10},{key:"526",word:"触发BFC的条件",type:"CSS",details:"\n    只要元素满足下面任一条件即可触发 BFC 特性\n\n    body 根元素\n    浮动元素：float 除 none 以外的值\n    绝对定位元素：position (absolute、fixed)\n    display 为 inline-block、table-cells、flex\n    overflow 除了 visible 以外的值 (hidden、auto、scroll)\n    ",latestReview:"2020/12/27",nextReview:"2021/1/1",count:2},{key:"527",word:"向HTML页面插入javaScript的主要方法",type:"javaScript",details:"\n    使用script元素\n    ",latestReview:"",nextReview:"",count:6},{key:"528",word:"什么是标识符",type:"javaScript",details:"\n    所谓标识符\n    就是变量、函数、属性的名字或函数的参数\n    ",latestReview:"",nextReview:"",count:0},{key:"529",word:"标识符的命名规则",type:"javaScript",details:"\n    第一个字符必须是一个字母、下划线_或一个美元符号$\n    其它字符可以是字母、下划线、美元符号或数字\n    ",latestReview:"2021/1/20",nextReview:"2021/1/21",count:0},{key:"530",word:"标识符的规则",type:"javaScript",details:"\n    第一个字符必须是一个字母、下划线_或一个美元符号$\n    其它字符可以是字母、下划线、美元符号或数字\n    ",latestReview:"",nextReview:"",count:0},{key:"531",word:"什么时候应将变量初始化为null",type:"javaScript",details:"\n    定义的变量准备用于保存对象\n    ",latestReview:"",nextReview:"",count:0},{key:"532",word:"js浮点数定义",type:"javaScript",details:"\n    该数值中必须包含一个小数点\n    并且小数点后必须至少有一位数字\n    ",latestReview:"",nextReview:"",count:0},{key:"533",word:"与整数相比浮点数的弊端",type:"javaScript",details:"\n    1、浮点数需要的内存空间是保存整数值的两倍\n    2、在进行算数计算时其精度远远不如整数\n      例：0.1 + 0.2 的结果不是0.3 而是 0.300000000000000004\n    ",latestReview:"2021/1/19",nextReview:"2021/1/20",count:0},{key:"534",word:"Js能够表示的最大数和最小数",type:"javaScript",details:"\n    最小数值：Number.MIN_VALUE\n    最大数值：Number.MAX_VALUE\n    ",latestReview:"",nextReview:"",count:0},{key:"535",word:"如果某次计算的结果超出Js数值范围 则",type:"javaScript",details:"\n    该数值将被自动转换成特殊的Infinity值\n    如果该值为负 则转换成 -Infinity(负无穷)\n    如果该值为正 则转换成 Infinity(正无穷)\n    ",latestReview:"2021/1/20",nextReview:"2021/1/21",count:10},{key:"536",word:"如何确定一个数值是否有穷",type:"javaScript",details:"\n    使用isFinite(num)函数\n    该函数在参数位于最小和最大值之间时会返回true\n\n    let res = Number.MAX_VALUE + Number.MAX_VALUE\n    alert(isFinite(res))  // false\n    ",latestReview:"",nextReview:"",count:6},{key:"537",word:"如何理解NaN",type:"javaScript",details:"\n    即非数值(Not a Number) 是一个特殊的数值\n    用于表示一个本来要返回数值的操作数未返回数值的情况\n    这样做的好处是不会抛出错误\n    ",latestReview:"",nextReview:"",count:6},{key:"538",word:"NaN两个特点",type:"javaScript",details:"\n    1、任何涉及NaN的操作都会返回NaN\n    2、NaN与任何值都不相等 包括NaN本身\n      alert(NaN === NaN)  // false\n    ",latestReview:"",nextReview:"",count:0},{key:"539",word:"isNaN()",type:"javaScript",details:"\n    isNaN()函数接受一个参数 参数可以是任何类型\n    isNaN()在接收到一个值之后 会尝试将这个值转换为数值\n    任何不能被转换为数值的值都会导致该函数返回true\n    ",latestReview:"",nextReview:"",count:0},{key:"540",word:"isNaN()",type:"javaScript",details:"\n    isNaN()函数接受一个参数 参数可以是任何类型\n    isNaN()在接收到一个值之后 会尝试将这个值转换为数值\n    任何不能被转换为数值的值都会导致该函数返回true\n    ",latestReview:"",nextReview:"",count:6},{key:"541",word:'isNaN("10")',type:"javaScript",details:"\n    false 因为字符串10可以被转换为数值10\n    ",latestReview:"2021/1/21",nextReview:"2021/1/24",count:1},{key:"542",word:'isNaN("blue")',type:"javaScript",details:"\n    true 不能转换成数值\n    ",latestReview:"",nextReview:"",count:10},{key:"543",word:"isNaN(true)",type:"javaScript",details:"\n    false 可以被转换成数值1\n    ",latestReview:"",nextReview:"",count:0},{key:"544",word:"将非数值转换为数值的三个函数",type:"javaScript",details:"\n    Number()\n    parseInt()\n    parseFloat()\n    ",latestReview:"",nextReview:"",count:6},{key:"545",word:"Number()和parseInt()、parseFloat()的区别",type:"javaScript",details:"\n    Number()可以用于任何数据类型\n    parseInt()、parseFloat(）专门用于把字符串转换成数值\n    ",latestReview:"2021/1/26",nextReview:"2021/1/29",count:1},{key:"546",word:"Number()转换基本类型规则",type:"javaScript",details:"\n    Boolean值：true和false分别被转换为1和0\n    数值：简单的传入和返回\n    null：返回0\n    undefined：NaN\n    字符串：\n    1、如果只包含数字（包含正负号）-> 转为十进制数值（会忽略前导0）\n    2、有效的浮点格式 -> 转为对应的浮点数值（会忽略前导0）\n    3、空字符串 -> 0\n    4、包含有效十六进制格式（如0xf）-> 转为相同大小的十进制整数值\n    5、字符串中包含除上述格式外的字符 -> NaN\n    ",latestReview:"",nextReview:"",count:0},{key:"547",word:"Number()转换对象规则",type:"javaScript",details:"\n    调用对象的valueOf()方法❓ 后依照基本类型规则转换\n    如果转换结果为NaN 则调用对象的toString()方法 再次依照基本类型规则转换\n    ",latestReview:"",nextReview:"",count:0},{key:"548",word:"parseInt()转换规则",type:"javaScript",details:"\n    1、忽略字符串前面的空格，直至找到第一个非空字符串\n    2、如果第一个字符不是数字字符或负号 则返回NaN\n    3、如果第一个字符是数字字符则继续解析第二个\n      直到解析完所有字符或或遇到一个非数字字符\n    ",latestReview:"2021/1/19",nextReview:"2021/1/20",count:0},{key:"549",word:'parseInt("x3")',type:"javaScript",details:"\n    NaN\n    ",latestReview:"",nextReview:"",count:0},{key:"550",word:'parseInt("3x")',type:"javaScript",details:"\n    3\n    ",latestReview:"",nextReview:"",count:0},{key:"551",word:"console.log(3e-2)",type:"javaScript",details:"\n    0.03\n    ",latestReview:"",nextReview:"",count:10},{key:"552",word:"console.log(3e2)",type:"javaScript",details:"\n    300\n    ",latestReview:"",nextReview:"",count:0},{key:"553",word:'parseFloat("22.34.5")',type:"javaScript",details:"\n    22.34\n    ",latestReview:"",nextReview:"",count:0},{key:"554",word:"全等===和相等==的区别",type:"javaScript",details:'\n    全等表示数值不经过转换的情况下就相等\n    var result1 = ("55" == 55)  // true\n    var result1 = ("55" === 55)  // false\n    ',latestReview:"",nextReview:"",count:10},{key:"555",word:"break和continue的异同",type:"javaScript",details:"\n    都用于控制代码执行\n    break语句：立即退出循环 强制执行循环后面的语句\n    continue语句：立即退出循环 从循环的顶部继续执行\n    ",latestReview:"",nextReview:"",count:10},{key:"556",word:"switch case合并两种情形",type:"javaScript",details:'\n    在需合并的情形前不要使用break语句退出\n    switch(i) {\n      case25:\n      case35:\n        alert("25 or 35")\n        break;\n      case45:\n        break;\n    }\n    ',latestReview:"2021/1/19",nextReview:"2021/1/20",count:0},{key:"557",word:"arguments对象是什么",type:"javaScript",details:"\n    函数的参数数组 可以获取传递给函数的每一个参数\n    ",latestReview:"2021/1/21",nextReview:"2021/1/24",count:1},{key:"558",word:"arguments对象是什么",type:"javaScript",details:"\n    函数的参数数组 可以获取传递给函数的每一个参数\n    注意：arguments不是Array的实例 是类数组\n    ",latestReview:"",nextReview:"",count:0},{key:"559",word:"执行环境的作用",type:"javaScript",details:"\n    执行环境是javaScript中重要的概念\n\n    执行环境定义了变量或函数有权访问其它数据\n    决定了他们各自的行为\n    ",latestReview:"2021/1/20",nextReview:"2021/1/21",count:0},{key:"560",word:"如何理解执行环境中的变量对象",type:"javaScript",details:"\n    每一个执行环境都有一个与之相关联的变量对象\n    环境中定义的所有变量和函数都保存在这个对象中\n\n    编写的代码无法访问该对象\n    解析器在处理数据时会在后台使用它\n    ",latestReview:"",nextReview:"",count:0},{key:"561",word:"什么是全局执行环境",type:"javaScript",details:"\n    全局执行环境是最外围的一个执行环境\n    ",latestReview:"2021/1/20",nextReview:"2021/1/21",count:0},{key:"562",word:"全局执行环境的特点",type:"javaScript",details:"\n    根据ES实现所在宿主环境不同\n    表示全局执行环境的对象也不同\n\n    例：在Web浏览器中 全局执行环境被认为是window对象\n    因此全局变量和函数都是作为window对象的属性和方法创建的\n    ",latestReview:"",nextReview:"",count:0},{key:"563",word:"全局执行环境的特点",type:"javaScript",details:"\n    根据ES实现所在宿主环境不同\n    表示全局执行环境的对象也不同\n\n    例：在Web浏览器中 全局执行环境被认为是window对象\n    因此全局变量和函数都是作为window对象的属性和方法创建的\n    ",latestReview:"",nextReview:"",count:0},{key:"564",word:"函数执行时执行环境如何变化",type:"javaScript",details:"\n    每个函数都有自己的执行环境\n    当执行流进入一个函数时 函数的执行环境就会被推入一个环境栈中\n    函数执行之后 环境栈将函数的执行环境弹出\n    将控制权返回给之前的执行环境\n    ",latestReview:"",nextReview:"",count:0},{key:"565",word:"函数“运行期上下文”",type:"javaScript",details:"\n    执行函数时会创建一个称为“运行期上下文(execution context)”的内部对象\n    运行期上下文定义了函数执行时的环境\n    每个运行期上下文有自己的作用域链，用于标识符解析\n    而它的作用域链初始化为当前函数的[[Scope]]所包含的对象\n    ",latestReview:"2021/1/20",nextReview:"2021/1/21",count:0},{key:"566",word:"函数“活动对象”",type:"javaScript",details:"\n    活动对象在函数「运行期上下文对象」的作用域链中\n    排在首位的是arguments对象\n    后来者来自外部环境\n    再后来者来自下一个外部环境\n    ",latestReview:"",nextReview:"",count:0},{key:"567",word:"let i = 0 console.log(i++)",type:"javaScript",details:"\n    0\n    先输出之前的i值 再++\n\n    function Foo() {\n      var i = 0;\n      return function() {\n          console.log(i++);\n      }\n    }\n    \n    var f1 = Foo(),\n        f2 = Foo()\n    f1()  // 0\n    f1()  // 1\n    ",latestReview:"",nextReview:"",count:0},{key:"568",word:"数组reduce方法",type:"javaScript",details:"\n    reduce为数组中的每一个元素依次执行回调函数\n    不包括数组中被删除或从未被赋值的元素\n    ",latestReview:"",nextReview:"",count:0},{key:"569",word:"数组reduce方法参数",type:"javaScript",details:"\n    接受四个参数：\n    初始值（或者上一次回调函数的返回值），当前元素值，当前索引，调用 reduce 的数组\n    ",latestReview:"",nextReview:"",count:0},{key:"570",word:"函数式编程求和",type:"javaScript",details:"\n    function sum(arr) {\n      return arr.reduce(function(prev, curr, idx, arr){\n        return prev + curr\n      })\n    }\n    简化写法\n    function sum(arr) {\n      return arr.reduce((prev, curr) => prev + curr)\n    }\n    ",latestReview:"2021/1/19",nextReview:"2021/1/20",count:0},{key:"571",word:"eval()方法",type:"javaScript",details:"\n    eval() 函数可计算某个字符串\n    ",latestReview:"",nextReview:"",count:0},{key:"572",word:'arr = [1, 2, 3, 4, 5] arr.join("+") = ？',type:"javaScript",details:"\n    1+2+3+4+5\n    ",latestReview:"",nextReview:"",count:0},{key:"573",word:"数组eval求和",type:"javaScript",details:'\n    function sum(arr) {\n      return eval(arr.join("+"))\n    }\n    ',latestReview:"2021/1/19",nextReview:"2021/1/20",count:0},{key:"574",word:"splice()移除数组中某元素 不改变原数组",type:"javaScript",details:"\n    function remove(arr, item){\n      let newArr = arr.slice(0)\n      for(let i = 0;i < newArr.length; i++){\n        if(newArr[i] === item){\n          newArr.splice(i, 1)\n          i--\n        }\n      }\n      return newArr\n    }\n    ",latestReview:"",nextReview:"",count:10},{key:"575",word:"数组filter方法",type:"javaScript",details:"\n    filter() 方法创建一个新的数组\n    新数组中的元素为「指定数组中符合条件的」所有元素\n    ",latestReview:"",nextReview:"",count:0},{key:"576",word:"filter移除数组中某元素",type:"javaScript",details:"\n    function remove(arr, item) {\n      return arr.filter(function(ele) {\n        return ele != item\n      })\n    }\n    简化写法\n    function remove(arr, item){\n      return arr.filter(ele => ele != item)\n    }\n    缺点：占用内存较多\n    ",latestReview:"",nextReview:"",count:0},{key:"577",word:"什么是OpenGL",type:"three.js",details:"\n    专业的图形程序接口\n    是一个功能强大，调用方便的底层图形库\n    ",latestReview:"",nextReview:"",count:0},{key:"578",word:"什么是WebGL",type:"three.js",details:"\n    WebGL是基于OpenGL ES 2.0的Web标准\n    可以通过HTML5 Canvas元素作为DOM接口访问\n    ",latestReview:"",nextReview:"",count:0},{key:"579",word:"什么是three.js",type:"three.js",details:"\n    Three.js是一个3D JavaScript库\n    封装了底层的图形接口\n    使得程序员能够在无需掌握繁冗的图形学知识的情况下\n    也能用简单的代码实现三维场景的渲染\n    ",latestReview:"",nextReview:"",count:0},{key:"580",word:"一个典型的Three.js程序至少包括",type:"three.js",details:"\n    1、渲染器（Renderer）\n    2、场景（Scene）\n    3、照相机（Camera）\n    4、在场景中创建的物体\n    ",latestReview:"2021/1/20",nextReview:"2021/1/21",count:0},{key:"581",word:"如何理解照相机",type:"three.js",details:"\n    使用Three.js创建的场景是三维的\n    通常情况下显示屏是二维的\n    照相机定义了三维空间到二维屏幕的投影方式\n    ",latestReview:"",nextReview:"",count:0},{key:"582",word:"两类相机及其理解",type:"three.js",details:"\n    正交投影相机（Orthographic Camera）\n    获得的结果是类似人眼在真实世界中看到的有“近大远小”的效果\n\n    透视投影照相机（Perspective Camera）\n    获得的结果就像我们在数学几何学课上老师教我们画的效果\n    对于在三维空间内平行的线\n    投影到二维空间中也一定是平行的\n    ",latestReview:"",nextReview:"",count:0},{key:"583",word:"右手坐标系",type:"three.js",details:"\n    使大姆指，食指和中指互成直角\n    大拇指指向x轴正方向\n    食指指向y轴的正方向时\n    中指所指的方向就是z轴的正方向\n    ",imgList:["key582-1.png"],latestReview:"",nextReview:"",count:0},{key:"584",word:"正交投影相机参数理解",type:"three.js",details:"\n    THREE.OrthographicCamera(left, right, top, bottom, near, far)\n    这六个参数分别代表正交投影照相机拍摄到的空间的六个面的位置\n    这六个面围成一个长方体，我们称其为视景体（Frustum）。\n    只有在视景体内部（下图中的灰色部分）的物体才可能显示在屏幕上\n    而视景体外的物体会在显示之前被裁减掉\n    ",imgList:["key583-1.jpg"],latestReview:"",nextReview:"",count:0},{key:"585",word:"透视投影相机参数理解",type:"three.js",details:"\n    THREE.PerspectiveCamera(fov, aspect, near, far)\n    透视图中，灰色的部分是视景体，是可能被渲染的物体所在的区域\n    fov是视景体竖直方向上的张角（是角度制而非弧度制）\n    aspect等于width / height，是照相机水平方向和竖直方向长度的比值\n    通常设为Canvas的横纵比例\n    near和far分别是照相机到视景体最近、最远的距离，均为正值，且far应大于near\n    ",imgList:["key584-1.jpg","key584-2.jpg"],latestReview:"",nextReview:"",count:0},{key:"586",word:"在创建物体时需传入哪两个参数",type:"three.js",details:"\n    在创建物体时，需要传入两个参数：\n    1、几何形状（Geometry）\n    2、材质（Material）\n    ",latestReview:"",nextReview:"",count:0},{key:"587",word:"几何形状（Geometry）的作用是",type:"three.js",details:"\n    几何形状（Geometry）最主要的功能是储存了一个物体的顶点信息\n    ",latestReview:"",nextReview:"",count:0},{key:"588",word:"什么是构造函数",type:"javaScript",details:"\n    构造函数，是用来创建对象的函数\n    本质上也是函数\n    ",latestReview:"",nextReview:"2021/2/1",count:0},{key:"589",word:"构造函数与其他函数的区别",type:"javaScript",details:"\n    与其他函数的区别在于调用方式不同：\n    如果通过new操作符来调用的，就是构造函数\n    如果没有通过new操作符来调用的，就是普通函数\n    ",latestReview:"",nextReview:"2021/2/1",count:0},{key:"590",word:"构造函数 例",type:"javaScript",details:"\n    function Person(name, age) {\n      this.name = name;\n      this.age = age;\n    }\n    //当做构造函数调用\n    var person1 = new Person('Mike',10);\n    \n    // 当做普通函数调用\n    // 这里相当于给window对象添加了name和age属性\n    Person('Bob',12);\n    \n    console.log(person1) // Person {name: \"Mike\", age: 10}\n    console.log(name) // Bob\n    console.log(age) // 12\n\n    在var person1 = new Person('Mike',10)中\n    通过new操作符调用了函数Person，并且生成了person1\n    这里的Person就称为构造函数\n    person1称为Person函数对象的一个实例\n    ",latestReview:"",nextReview:"2021/2/1",count:0},{key:"591",word:"实例如何访问构造函数",type:"javaScript",details:"\n    可以通过实例的constructor访问对应的构造函数\n    ",latestReview:"",nextReview:"2021/2/1",count:0},{key:"592",word:"prototype属性本质是",type:"javaScript",details:"\n    这个属性是一个指针\n    指向它的原型对象\n    ",latestReview:"",nextReview:"2021/2/1",count:0},{key:"593",word:"什么是原型对象",type:"javaScript",details:"\n    无论什么时候，只要创建了一个新函数\n    就会根据一组特定的规则为函数创建一个prototype属性\n    这个属性指向函数的原型对象\n\n    即原型对象是「函数的prototype属性」指向的对象\n    原型对象包含所有实例（构造函数创建）共享的属性和方法\n    ",imgList:["key593-1.png"],latestReview:"",nextReview:"2021/2/1",count:0},{key:"594",word:"如何理解原型对象",type:"javaScript",details:"\n    简单来说\n    该函数实例化的所有对象的__proto__的属性指向这个对象\n    它是该函数所有实例化对象的原型\n    ",latestReview:"",nextReview:"2021/2/1",count:0},{key:"595",word:"给原型对象添加方法 例",type:"javaScript",details:"\n    function Person(){\n      ...\n    }\n    // 为原型对象添加方法\n    Person.prototype.sayName = function(){\n      alert(this.name);\n    }\n    ",latestReview:"",nextReview:"2021/2/1",count:0},{key:"596",word:"原型对象constructor属性",type:"javaScript",details:"\n    这个属性是一个指针\n    指向 prototype 所在的函数对象（的指针）\n    ",imgList:["key596-1.png"],latestReview:"",nextReview:"2021/2/1",count:0},{key:"597",word:"__proto__属性是什么",type:"javaScript",details:"\n    调用构造函数创建一个新实例后\n    在这个实例的内部将包含一个指针，指向构造函数的原型对象\n    该属性就是 __proto__\n    需要注意的是\n    在 ECMA-262 第五版中管这个指针叫做 [[Prototype]]\n    所有的对象都含有 [[Prototype]] 属性，指向它们的原型对象\n\n    在脚本中没有标准的方式访问 [[Prototype]] 属性\n    但是在 Firefox，Safari 和 Chrome 中\n    每个对象中都支持一个属性 __proto__ 来访问\n    ",imgList:["key596-1.png"],latestReview:"",nextReview:"2021/2/1",count:0},{key:"598",word:"函数对象 原型对象 实例对象之间的关系",type:"javaScript",details:"\n    var student = new Person();\n    console.log(student.__proto__ === Person.prototype); // true\n    ",imgList:["key598-1.png"],latestReview:"",nextReview:"2021/2/1",count:10},{key:"599",word:"使用原型对象的好处",type:"javaScript",details:"\n    让所有对象实例共享它所包含的属性和方法\n    ",latestReview:"",nextReview:"2021/2/1",count:0},{key:"600",word:"isPrototypeOf()方法",type:"javaScript",details:"\n    用于测试一个对象是否存在于另一个对象的原型链上\n\n    例：判断student是否在Person的原型链上\n    console.log(Person.prototype.isPrototypeOf(student)) // true\n    student内部含有一个指向Person.prototype的指针 因此返回true\n    ",latestReview:"",nextReview:"2021/2/1",count:0},{key:"601",word:"Object.getPrototypeOf()方法",type:"javaScript",details:"\n    返回[[Prototype]]的值\n    返回的对象实际就是这个对象的原型\n\n    例：\n    alert(Object.getPrototypeOf(student) == Person.prototype)  // true\n    alert(Object.getPrototypeOf(student).name)  // 可以访问name属性\n    ",latestReview:"",nextReview:"2021/2/1",count:0},{key:"602",word:"原型对象思维导图",type:"javaScript",details:"",imgList:["key602-1.jpg"],latestReview:"",nextReview:"2021/2/1",count:0},{key:"603",word:"原型链基本继承代码",type:"javaScript",details:"\n    function SuperType() {\n      this.property = true\n    }\n    SuperType.prototype.getSuperValue = function() {\n      return this.property\n    }\n\n    function SubType() {\n      this.subProperty = false\n    }\n    SubType.prototype.getSubValue = function() {\n      return this.subProperty\n    }\n\n    SubType.prototype = new SuperType()\n\n    var instance = new SubType()\n    console.log(instance.getSuperValue())\n    ",latestReview:"",nextReview:"2021/2/1",count:10},{key:"604",word:"原型链实现继承的本质是",type:"javaScript",details:"\n    实现的本质是重写原型 取而代之一个新的类型实例\n    也就是说原来在超类中的实例和方法也新增存于子类中\n    ",latestReview:"",nextReview:"2021/2/1",count:10},{key:"605",word:"new操作符实现",type:"javaScript",details:"\n    function Person( name ){\n      this.name = name\n    }\n    Person.prototype.getName = function() { \n      return this.name\n    }\n    var objectFactory = function() {\n      var obj = new Object() 或 {},  // 从 Object.prototype 上克隆一个空的对象\n      Constructor = [].shift.call( arguments )  // 取得外部传入的构造器，此例是 Person\n      obj.__proto__ = Constructor.prototype  // 指向正确的原型\n      var ret = Constructor.apply( obj, arguments )\n      return typeof ret === 'object' ? ret : obj\n    }\n\n    console.log( a.name )  // 输出:sven\n    console.log( a.getName() )  // 输出:sven\n    console.log( Object.getPrototypeOf( a ) === Person.prototype )  // 输出:true\n\n    我们看到，分别调用下面两句代码产生了一样的结果:\n    var a = objectFactory( A, 'sven' )\n    var a = new A( 'sven' )\n    ",latestReview:"",nextReview:"2021/2/1",count:10},{key:"606",word:"函数构造器调用",type:"javaScript",details:"\n    JavaScript 中没有类\n    但是可以从构造器中创建对象\n    除了宿主提供的一些内置函数，大部分 JavaScript 函数都可以当作构造器使用\n    同时也提供了 new 运算符，使得构造器看起来更像一个类\n    当用 new 运算符调用函数时，该函数总会返回一个对象\n    ",latestReview:"",nextReview:"2021/2/1",count:0},{key:"607",word:"原型继承过程理解",type:"javaScript",details:"\n    当我们期望得到一个“类”继承自另外一个“类”的效果时\n    往往会用下面的代码来模拟实现:\n\n    var a = new A()\n    A.prototype = { name: 'sven }\n\n    var B = function() {}\n    B.prototype = new A()\n\n    var b = new B()\n    console.log( b.name )\n\n    1、首先，尝试遍历对象 b 中的所有属性，但没有找到 name 这个属性\n    2、查找 name 属性的请求被委托给对象 b 的构造器的原型\n      它被 b.__proto__ 记录着并且指向 B.prototype\n      而 B.prototype 被设置为一个通过 new A()创建出来的对象\n      在该对象中依然没有找到 name 属性\n      于是请求被继续委托给这个对象构造器的原型 A.prototype。\n    3、在 A.prototype 中找到了 name 属性，并返回它的值\n    ",latestReview:"",nextReview:"2021/2/1",count:0},{key:"608",word:"js this的特点",type:"javaScript",details:"\n    JavaScript 的 this 总是指向一个对象，而具体指向哪个对象是在\n    运行时基于函数的执行环境动态绑定的，而非函数被声明时的环境\n    ",latestReview:"",nextReview:"2021/2/1",count:0},{key:"609",word:"this丢失问题",type:"javaScript",details:"\n    this在作为对象方法调用时和作为普通函数调用时候产生的冲突\n    如对象方法中再定义一个function\n    该function中的this指向window\n    ",latestReview:"",nextReview:"2021/2/1",count:0},{key:"610",word:"this丢失问题解决办法",type:"javaScript",details:"\n    1、使用一个变量保存之前this的引用\n    2、使用apply、call改变this\n    ",latestReview:"",nextReview:"2021/2/1",count:0},{key:"611",word:"this丢失例子",type:"javaScript",details:"\n    1、将对象中的方法赋给一个新变量 新变量调用时变为普通函数调用 this改变\n    2、在对象方法中定义的方法被调用时 变为普通函数调用 this改变\n    ",latestReview:"",nextReview:"2021/2/1",count:0},{key:"612",word:"call、apply本质区别",type:"javaScript",details:"\n    call 是包装在 apply 上面的一颗语法糖\n    ",latestReview:"",nextReview:"2021/2/1",count:0},{key:"613",word:"什么时候需要使用call",type:"javaScript",details:"\n    如果我们明确地知道函数接受多少个参数\n    而且想一目了然地表达形参和实参的对应关系\n    那么也可以用 call 来传送参数\n    ",latestReview:"",nextReview:"2021/2/1",count:0},{key:"614",word:"call、apply用途",type:"javaScript",details:"\n    1、改变this指向\n    2、借用方法\n    3、实现bind\n    ",latestReview:"",nextReview:"2021/2/1",count:0},{key:"615",word:"bind实现",type:"javaScript",details:"\n    Function.prototype.bind = function( context ) {\n      /*\n       * 此处的this即为函数实例，原因如下：\n       * Function.prototype.bind给函数原型中添加方法\n       * 原型对象中拥有该方法后函数实例也拥有\n       * 函数实例是一个对象 对象方法中的this指向它本身\n       * 而该对象本身是函数\n       * 因此 this.apply(..)直接相当于调用函数\n      */\n      console.log(this)\n      var self = this; // 保存原函数\n      return function() { // 返回一个新的函数\n        // 执行新的函数的时候，会把之前传入的 context 当作新函数体内的 this\n        return self.apply( context, arguments )\n      }\n    }\n    var obj = { name: 'sven' }\n    \n    var func = function() {\n      alert ( this.name )\n    }.bind( obj)\n\n    func()\n    ",latestReview:"",nextReview:"2021/2/1",count:0},{key:"616",word:"函数中使用var声明的变量",type:"javaScript",details:"\n    是局部变量\n    ",latestReview:"",nextReview:"2021/2/1",count:10},{key:"617",word:"什么是变量的作用域",type:"javaScript",details:"\n    变量的有效范围\n    ",latestReview:"",nextReview:"2021/2/1",count:0},{key:"618",word:"垂直水平居中方法（6种）",type:"CSS",details:"\n    ①不定宽高 父元素relative;\n      子元素 absolute;transform: translate(-50%, -50%);\n      left:50%;top:50%;\n    ②定宽定高 可用margin 值为当前div宽度一半的负值\n    ③绝对定位下 margin: auto; top left right bottom 都设置0\n    ④flex\n    ⑤table-cell text-align:center,vertical-align: middle;\n    ⑥定宽定高 calc动态计算\n    ",latestReview:"",nextReview:"2021/2/1",count:0},{key:"619",word:"Vue怎么实现对数组变化检测",type:"Vue",details:"\n    使用「函数劫持」的方式，重写了数组的方法；\n    vue 将 data 中的数据，进行了「原型链重写」，指向了自己定义的数组原型方法；\n    这样当调用数组 api 的时候，可以通知依赖更新；\n    如果数组中包含着引用类型，则会对数组中的引用类型再次进行监控；\n\n    但由于 JavaScript 的限制， Vue 不能检测以下变动的数组：\n    1、当你利用索引直接设置一个项时，例如： vm.items[indexOfItem] = newValue\n    2、当你修改数组的长度时，例如： vm.items.length = newLength\n\n    为解决上述问题可使用\n    // Vue.set\n    Vue.set(example1.items, indexOfItem, newValue)\n    // Array.prototype.splice\n    example1.items.splice(indexOfItem, 1, newValue)\n\n    为了解决第二类问题，你可以使用 splice：\n    example1.items.splice(newLength)\n    ",latestReview:"",nextReview:"2021/2/1",count:10},{key:"620",word:"函数中未使用var的变量会如何",type:"javaScript",details:"\n    当在函数中声明一个变量的时候，如果该变量前面没有带上关键字 var\n    这个变量就会成为 全局变量，这当然是一种容易造成命名冲突的做法\n    ",latestReview:"",nextReview:"2021/2/1",count:10},{key:"621",word:"函数中搜索变量的过程",type:"javaScript",details:"\n    在函数中搜索一个变量的时候\n    如果该函数内并没有声明这个变量\n    那么此次搜索的过程会随着代码执行环境\n    创建的作用域链往外层逐层搜索\n    一直搜索到全局对象为止\n\n    此时的函数像一层半透明的玻璃\n    在函数里面可以看到外面的变量\n    而在函数外面则无法看到函数里面的变量\n    ",latestReview:"",nextReview:"2021/2/1",count:0},{key:"622",word:"如何理解闭包return function",type:"javaScript",details:"\n    return function返回了一个匿名函数的引用\n    它可以访问到「函数被调用时产生的环境」\n    （调用时不好理解可理解为创建时）\n    （创建时写的代码在执行时会走一遍）\n    此时即可拿到函数中的局部变量\n    由于该局部变量还可以被外界访问到\n    所以该局部变量就有了不被销毁的理由\n    ",latestReview:"",nextReview:"2021/2/1",count:0},{key:"623",word:"闭包经典应用：循环遍历异步",type:"javaScript",details:"\n    该情况执行的结果依次打印的是for循环执行完成后的结果\n    for(var i = 0; i < 5; i++) {\n      setTimeout(function() {\n        console.log(i)\n      })\n    }\n    5 5 5 5 5\n    \n    闭包可以将每次循环的i值封闭起来\n    for(var i = 0; i < 5; i++) {\n      (function(i) {\n        setTimeout(function() {\n          console.log(i)\n        })\n      })(i)\n    }\n    0 1 2 3 4\n    ",latestReview:"",nextReview:"2021/2/1",count:0},{key:"624",word:"闭包用途",type:"javaScript",details:"\n    1、封装变量\n      闭包可以帮助把一些不需要暴露在全局的变量封装成“私有变量”\n    2、延续局部变量的寿命\n    ",latestReview:"",nextReview:"2021/2/1",count:0},{key:"625",word:"过程与数据结合（面向对象、闭包）",type:"javaScript",details:"\n    过程与数据的结合是形容面向对象中的“对象”时经常使用的表达\n    对象以「方法的形式」「包含了过程」\n    而闭包则是「在过程中」以环境的形式「包含了数据」\n    通常用面向对象思想能实现的功能，用闭包也能实现。反之亦然\n\n    闭包写法\n    var extent = function() {\n      var value = 0\n      return {\n        call: function() {\n          value++\n          console.log( value )\n        }\n      }\n    }\n    var extent = extent()\n\n    面向对象写法\n    var extent = {\n      value: 0,\n      call: function() {\n        this.value++;\n        console.log( this.value )\n      }\n    }\n\n    extent.call() // 输出:1\n    extent.call() // 输出:2\n    extent.call() // 输出:3\n    ",latestReview:"",nextReview:"2021/2/1",count:0},{key:"626",word:"闭包内存泄露实质",type:"javaScript",details:"\n    跟闭包和内存泄露有关系的地方是，使用闭包的同时比较容易形成循环引用\n    如果闭包的作用域链中保存着一些 DOM 节点，这时候就有可能造成内存泄露\n\n    但这本身并非闭包的问题，也并非 JavaScript 的问题\n\n    在基于引用计数策略的垃圾回收机制中\n    如果两个对象之间形成了循环引用，那么这两个对象都无法被回收\n    但循环引用造成的内存泄露在本质上也不是闭包造成的\n    ",latestReview:"",nextReview:"2021/2/1",count:0},{key:"627",word:"闭包内存泄露解决方案",type:"javaScript",details:"\n    要解决循环引用带来的内存泄露问题，我们只需要把循环引用中的变量设为 null 即可\n    将变量设置为 null 意味着切断变量与它此前引用的值之间的连接\n    当垃圾收集器下次运行时，就会删除这些值并回收它们占用的内存\n    ",latestReview:"",nextReview:"2021/2/1",count:0},{key:"628",word:"什么是高阶函数",type:"javaScript",details:"\n    高阶函数是指至少满足下列条件之一的函数：\n     函数可以作为参数被传递\n     函数可以作为返回值输出\n    ",latestReview:"",nextReview:"2021/2/1",count:0},{key:"629",word:"Js单线程的优点",type:"javaScript",details:"\n    Js单线程是由其最初的用途来决定的：与浏览器交互\n    优点是保持了「保证了程序执行的一致性」\n    试想一下：\n    如果javascript是多线程的，那么当两个线程同时对dom进行一项操作\n    例如一个向其添加事件，而另一个删除了这个dom，此时该如何处理呢？\n    ",latestReview:"",nextReview:"2021/2/1",count:10},{key:"630",word:"Js单线程的弊端",type:"javaScript",details:"\n    单线程在保证了执行顺序的同时也限制了javascript的效率\n    ",latestReview:"",nextReview:"2021/2/1",count:0},{key:"631",word:"web worker实现多线程的弊端",type:"javaScript",details:"\n    1、所有新线程都受主线程的完全控制，不能独立执行\n      这意味着这些“线程” 实际上应属于主线程的子线程\n    2、这些子线程并没有执行I/O操作的权限\n      只能为主线程分担一些诸如计算等任务\n    ",latestReview:"",nextReview:"2021/2/1",count:0},{key:"632",word:"Js如何实现非阻塞",type:"javaScript",details:"\n    使用 event loop（事件循环）\n    ",latestReview:"",nextReview:"2021/2/1",count:0},{key:"633",word:"Js在调用方法时会生成什么",type:"javaScript",details:"\n    当我们调用一个方法的时候\n    js会生成一个与这个方法对应的执行环境（context）\n    又叫执行上下文\n    ",latestReview:"",nextReview:"2021/2/1",count:0},{key:"634",word:"执行环境（上下文）中有什么",type:"javaScript",details:"\n    这个执行环境中存在\n    1、这个方法的私有作用域\n    2、上层作用域的指向\n    3、方法的参数\n    4、这个作用域中定义的变量\n    5、这个作用域的this对象\n    ",latestReview:"",nextReview:"2021/2/1",count:10},{key:"635",word:"执行栈运作过程",type:"javaScript",details:"\n    js是单线程的，同一时间只能执行一个方法\n    于是这些方法被排队在一个单独的地方\n    这个地方被称为执行栈\n\n    当一个脚本第一次执行的时候\n    js引擎会解析这段代码\n    并将其中的同步代码按照执行顺序加入执行栈中\n    然后从头开始执行\n\n    如果当前执行的是一个方法\n    那么js会向执行栈中添加这个方法的执行环境\n    然后进入这个执行环境继续执行其中的代码\n\n    当这个执行环境中的代码\n    执行完毕并返回结果后\n    js会退出这个执行环境并把这个执行环境销毁\n    回到上一个方法的执行环境\n\n    这个过程反复进行\n    直到执行栈中的代码全部执行完毕\n    ",latestReview:"",nextReview:"2021/2/1",count:10},{key:"636",word:"什么是事件队列",type:"javaScript",details:"\n    js引擎遇到一个异步事件后并不会一直等待其返回结果\n    而是会将这个事件挂起，继续执行执行栈中的其他任务\n    \n    当一个异步事件返回结果后\n    js会将这个事件加入与当前执行栈不同的另一个队列\n    我们称之为事件队列\n    ",latestReview:"",nextReview:"2021/2/1",count:10},{key:"637",word:"事件队列的运行过程",type:"javaScript",details:"\n    被放入事件队列不会立刻执行其回调\n    而是等待当前执行栈中的所有任务都执行完毕\n    主线程处于闲置状态时\n    主线程会去查找事件队列是否有任务\n\n    如果有，那么主线程会从中取出排在第一位的事件\n    并把这个事件对应的回调放入执行栈中，然后执行其中的同步代码\n    如此反复，这样就形成了一个无限的循环\n    ",latestReview:"",nextReview:"2021/2/1",count:10},{key:"638",word:"异步任务被分为哪两类",type:"javaScript",details:"\n    微任务（micro task）\n    宏任务（macro task）\n    ",latestReview:"",nextReview:"2021/2/1",count:10},{key:"639",word:"宏任务有哪些",type:"javaScript",details:"\n    setInterval()\n    setTimeout()\n    ",latestReview:"",nextReview:"2021/2/1",count:10},{key:"640",word:"微任务有哪些",type:"javaScript",details:"\n    new Promise()\n    new MutaionObserver()\n    ",latestReview:"",nextReview:"2021/2/1",count:10},{key:"641",word:"事件队列如何处理宏任务微任务",type:"javaScript",details:"\n    在一个事件循环中\n    异步事件返回结果后会被放到一个任务队列中\n\n    然而，根据这个异步事件的类型\n    这个事件实际上会被对应的宏任务队列或者微任务队列中去\n\n    在当前执行栈为空的时候\n    主线程会查看微任务队列是否有事件存在\n    如果不存在\n    那么再去宏任务队列中取出一个事件并把对应的回到加入当前执行栈\n\n    如果存在，则会依次执行队列中事件对应的回调\n    直到微任务队列为空，然后去宏任务队列中取出最前面的一个事件\n    把对应的回调加入当前执行栈\n    \n    如此反复，进入循环\n    ",latestReview:"",nextReview:"2021/2/1",count:10},{key:"642",word:"宏任务微任务执行规则",type:"javaScript",details:"\n    当前执行栈执行完毕时会立刻先处理所有微任务队列中的事件\n    然后再去宏任务队列中取出一个事件\n    \n    同一次事件循环中\n    微任务永远在宏任务之前执行\n    ",latestReview:"",nextReview:"2021/2/1",count:10},{key:"643",word:"宏任务微任务代码例",type:"javaScript",details:"\n    setTimeout(function () {\n      console.log(1);\n    });\n    \n    new Promise(function(resolve,reject){\n        console.log(2)\n        resolve(3)\n    }).then(function(val){\n        console.log(val);\n    })\n\n    2\n    3\n    1\n    ",latestReview:"",nextReview:"2021/2/1",count:10},{key:"644",word:"为什么会出现跨域问题",type:"javaScript",details:"\n    基于浏览器的同源策略限制\n    ",latestReview:"",nextReview:"2021/2/1",count:0},{key:"645",word:"什么是同源",type:"javaScript",details:"\n    同源（即指在同一个域）\n    就是两个页面具有相同的协议（protocol），主机（host）和端口号（port）\n\n    当前页面url\t被请求页面url\t是否跨域\t原因\n    http://www.test.com/\thttp://www.test.com/index.html\t否\t同源（协议、域名、端口号相同）\n    http://www.test.com/\thttps://www.test.com/index.html\t跨域\t协议不同（http/https）\n    http://www.test.com/\thttp://www.baidu.com/\t跨域\t主域名不同（test/baidu）\n    http://www.test.com/\thttp://blog.test.com/\t跨域\t子域名不同（www/blog）\n    http://www.test.com:8080/\thttp://www.test.com:7001/\t跨域\t端口号不同（8080/7001）\n    ",latestReview:"",nextReview:"2021/2/1",count:10},{key:"646",word:"跨域解决方法",type:"javaScript",details:"\n    1、JSONP\n    2、CORS\n    ",latestReview:"",nextReview:"2021/2/1",count:0},{key:"647",word:"js几种继承方式",type:"javaScript",details:"\n    1、原型链继承\n    2、借用构造函数继承\n    3、组合继承\n    4、原型式继承\n    5、寄生式继承\n    6、寄生组合式继承\n    ",latestReview:"",nextReview:"2021/2/1",count:10},{key:"648",word:"页面性能优化方法",type:"javaScript",details:"\n    1、资源压缩合并，减少http请求\n    2、非核心代码异步加载 --\x3e 异步加载的方式 --\x3e 异步加载的区别\n    3、利用浏览器缓存 --\x3e 缓存的分类 --\x3e 缓存的原理\n    4、使用CDN\n    5、DNS预解析\n    ",latestReview:"",nextReview:"2021/2/1",count:10},{key:"649",word:"什么是CDN",type:"javaScript",details:"\n    CDN又称为内容分发网络\n    本意在于尽可能避免开互联网上所有可能影响数据传输速度和稳定性的瓶颈和环节\n    是内容传输的更快，更稳定\n    解决因分布,带宽，服务器性能带来的访问延迟问题，适用于站点加速，点播，直播等场景\n    ",latestReview:"",nextReview:"2021/2/1",count:10},{key:"650",word:"call实现",type:"javaScript",details:"\n    思路：给某对象添加一个方法 执行后再删除\n    Function.prototype.myCall = function(obj) {\n      obj.fn = this\n      obj.fn()\n      delete obj.fn\n    }\n    \n    var obj = { name: 'zcb' }\n    \n    function callName() {\n      console.log(this.name)\n    }\n    \n    callName.myCall(obj)\n    ",latestReview:"",nextReview:"2021/2/1",count:10},{key:"651",word:"什么是HTTP",type:"javaScript",details:"\n    是互联网上应用最为广泛的一种网络协议\n    是一个客户端和服务器端请求和应答的标准（TCP）\n    用于从WWW服务器传输超文本到本地浏览器的传输协议\n    它可以使浏览器更加高效，使网络传输减少\n    ",latestReview:"",nextReview:"2021/2/1",count:10},{key:"652",word:"什么是HTTPS",type:"javaScript",details:"\n    是以安全为目标的HTTP通道\n    简单讲是HTTP的安全版\n    即HTTP下加入SSL层\n    HTTPS的安全基础是SSL\n    因此加密的详细内容就需要SSL\n    ",latestReview:"",nextReview:"2021/2/1",count:10},{key:"653",word:"HTTP协议为什么不安全",type:"javaScript",details:"\n    HTTP协议传输的数据都是未加密的\n    也就是明文的\n    因此使用HTTP协议传输隐私信息非常不安全\n    ",latestReview:"",nextReview:"2021/2/1",count:10},{key:"654",word:"HTTP与HTTPS的区别",type:"javaScript",details:"\n    1、https协议需要到ca申请证书\n      一般免费证书较少，因而需要一定费用。\n　　 2、http是超文本传输协议，信息是明文传输\n      https则是具有安全性的ssl加密传输协议。\n　　 3、http和https使用的是完全不同的连接方式，用的端口也不一样\n      前者是80，后者是443。\n　　 4、http的连接很简单，是无状态的；\n      HTTPS协议是由SSL+HTTP协议构建的可进行加密传输\n      身份认证的网络协议，比http协议安全\n    ",latestReview:"",nextReview:"2021/2/1",count:10},{key:"655",word:"一列布局的核心实现",type:"javaScript",details:"\n    \n    margin: 0 auto;\n    max-width: 960px;\n    height: 400px;\n\n    注意：块状元素不设置宽度，宽度默认是父元素宽度的100%\n    详见Css笔记 一列布局\n    ",latestReview:"",nextReview:"2021/2/1",count:10},{key:"656",word:"两栏布局的两种场景",type:"javaScript",details:"\n    1、左边定宽 右边自适应\n    2、左边不定宽 右边自适应\n    ",latestReview:"",nextReview:"2021/2/1",count:10},{key:"657",word:"两栏布局：左定宽 右自适应 实现方法",type:"javaScript",details:"\n    1、float + margin\n    2、float + 触发BFC\n    3、父相子绝\n    4、flex布局\n    5、table布局\n    ",latestReview:"",nextReview:"2021/2/1",count:10},{key:"658",word:"❗️",type:"javaScript",details:"\n    1、flex\n    2、浮动 + BFC\n    ",latestReview:"",nextReview:"2021/2/1",count:0},{key:"659",word:"创建vue实例的理解",type:"Vue",details:"\n    通过用Vue函数创建一个新的Vue实例\n\n    var vm = new Vue({\n      // 选项\n    })\n    ",latestReview:"",nextReview:"",count:10},{key:"660",word:"vm变量的语意",type:"Vue",details:"vm (ViewModel 的缩写) 这个变量名表示Vue实例",latestReview:"",nextReview:"",count:10},{key:"661",word:"Vue data对象的特殊之处",type:"Vue",details:"\n    当一个 Vue 实例被创建时\n    它将 data 对象中的所有的 property 加入到 Vue 的响应式系统中\n    当这些 property 的值发生改变时，视图将会产生“响应”，即匹配更新为新的值\n    ",latestReview:"",nextReview:"",count:10},{key:"662",word:"Vue data中的属性为什么要提前定义",type:"Vue",details:"\n    只有当实例被创建时就已经存在于 data 中的 property 才是响应式的\n    ",latestReview:"",nextReview:"",count:10},{key:"663",word:"Vue 如何使data对象失效",type:"Vue",details:"\n    唯一的例外是使用 Object.freeze()\n    这会阻止修改现有的 property\n    也意味着响应系统无法再追踪变化\n    ",latestReview:"",nextReview:"",count:10},{key:"664",word:"vm.$data 是什么",type:"Vue",details:"Vue 实例观察的数据对象",latestReview:"",nextReview:"",count:10},{key:"665",word:"vm.$props 是什么",type:"Vue",details:"当前组件接收到的 props 对象",latestReview:"",nextReview:"",count:10},{key:"666",word:"vm.$el 是什么",type:"Vue",details:"Vue 实例使用的根 DOM 元素",latestReview:"",nextReview:"",count:10},{key:"667",word:"Vue 生命周期方法中this指向",type:"Vue",details:"生命周期钩子的this上下文指向调用它的 Vue 实例",latestReview:"",nextReview:"",count:10},{key:"668",word:"Vue 计算属性中this指向",type:"Vue",details:"计算属性中的this指向vue实例",latestReview:"",nextReview:"",count:10},{key:"669",word:"计算属性function理解",type:"Vue",details:"计算属性的function将用作其getter函数",latestReview:"",nextReview:"",count:10},{key:"670",word:"快捷键 向下复制行",type:"javaScript",details:"option + shift + ↓",latestReview:"",nextReview:"",count:10},{key:"671",word:"冒泡排序的特点",type:"数据结构与算法",details:"\n    最慢的排序算法之一\n    最容易实现的排序算法\n    ",latestReview:"",nextReview:"",count:10},{key:"672",word:"“冒泡”理解",type:"数据结构与算法",details:"\n    之所以叫冒泡排序是因为使用这种排序算法排序时\n    数据值会像气泡一样从数组的一端漂浮到另一端。\n    假设正在将一组数字按照升序排列:\n    较大的值会浮动到数组的右侧，而较小的值则会浮动到数组的左侧\n    ",latestReview:"",nextReview:"",count:10},{key:"673",word:"冒泡排序 基本实现思路",type:"数据结构与算法",details:"\n    比较相邻的两个元素，如果前一个比后一个大，则交换位置\n    比较完第一轮的时候，最后一个元素是最大的元素\n    此时最后一个元素是最大的，所以最后一个元素就不需要参与比较大小，因此下一次排序数据需要交换的次数会少一次\n    ",latestReview:"",nextReview:"",count:10},{key:"674",word:"冒泡排序 代码实现",type:"数据结构与算法",details:"\n    var arr = [4, 23, 100, 9, 7, 49, 36, 57]\n\n    function bubbleSort(arr) {\n      for (let i = 0; i < arr.length - 1; i++) {\n        for (let j = 0; j < arr.length - i - 1; j++) {\n          if (arr[j] > arr[j + 1]) {\n            let temp = arr[j]\n            arr[j] = arr[j + 1]\n            arr[j + 1] = temp\n          }\n        }\n      }\n      return arr\n    }\n\n    bubbleSort(arr) //[4, 7, 9, 23, 36, 49, 57, 100]\n    ",latestReview:"",nextReview:"",count:10},{key:"675",word:"冒泡排序 arr.length - i - 1",type:"数据结构与算法",details:"\n    i代表第几次循环\n    循环了几次就代表有几个数值已经完成排序 无须参加下一次排序\n    因此内内循环要减去已完成的循环次数\n    ",latestReview:"",nextReview:"",count:10},{key:"676",word:"React Hook使用了什么机制",type:"React",details:"Hook 使用了 JavaScript 的闭包机制",latestReview:"",nextReview:"",count:10},{key:"677",word:"useEffect()的优点",type:"React",details:"\n    1、使用 useEffect 调度的 effect 不会阻塞浏览器更新屏幕，这让你的应用看起来响应更快\n    2、使用多个 Effect 实现关注点分离，这会将不相关逻辑分离到不同的 effect 中\n    ",latestReview:"",nextReview:"",count:10},{key:"678",word:"vw、vh",type:"CSS",details:"\n    vw：视窗宽度，1vw等于视窗宽度的1%。\n    vh：视窗高度，1vh等于视窗高度的1%\n    ",latestReview:"",nextReview:"",count:10}]}}]);